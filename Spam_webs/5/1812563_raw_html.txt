<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="content-type"/>
  <meta content="en-us" http-equiv="Content-Language"/>
  <meta content="C++ interview cheat sheet and reference, with concise info on the basic C++ concepts you need to ace the C++ techinical interview, including polymorphism, virtual, abstract base classes, constructors, encapsulation, inheritance, const, mutable, etc." name="description"/>
  <meta content="c++,interview,reference,constructor,polymorphism,virtual,abstract base classes, constructors, encapsulation, inheritance, const, mutable" name="keywords"/>
  <meta content="all" name="robots"/>
  <link href="/css/main.css" rel="stylesheet" type="text/css"/>
  <script src="/js/jquery.js" type="text/javascript">
  </script>
  <script src="/js/minscroll.js" type="text/javascript">
  </script>
  <script src="/js/dynacomments.js" type="text/javascript">
  </script>
  <script src="/js/permalinker.js" type="text/javascript">
  </script>
  <title>
   C++ Interview Resource Kiosk -- Basic C++ Interview Stuff
  </title>
  <meta content="SrKrNBuhciQdtI6ycDY14wI6wiELe2qkusaP2Zg7LPU=" name="verify-v1"/>
 </head>
 <body id="basics">
  <script type="text/javascript">
   var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-255547-4']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
  })();
  </script>
  <div id="outer">
   <div id="banner">
    <h1>
     <a href="/">
      C++ Interview Reference Kiosk
     </a>
    </h1>
    <h2>
     <a href="/">
      Your one-stop-shop for info and linkage
     </a>
    </h2>
   </div>
   <ul id="menu">
    <li>
     <span id="menu_basics">
      Basics
     </span>
    </li>
    <li>
     <a href="/tricky.html" id="menu_tricky">
      Trickier Stuff
     </a>
    </li>
    <li>
     <a href="/noncpp.html" id="menu_noncpp">
      Non C++ Stuff
     </a>
    </li>
    <!--&lt;li&gt;&lt;a id="coding_philosopies" href="/philosophies.html"&gt;Coding Philosophies&lt;/a&gt;&lt;/li&gt;-->
    <li>
     <a href="/links.html" id="menu_links">
      Useful Links
     </a>
    </li>
    <li>
     <a href="/books.html" id="menu_books">
      Useful Books
     </a>
    </li>
   </ul>
   <div id="main">
    <div id="content">
     <h1>
      Basic Stuff
     </h1>
     <h2>
      This is stuff that is sure to come up in a typical interview for a C++ software engineering position
     </h2>
     <dl>
      <dt id="encapsulation">
       Encapsulation
      </dt>
      <dd>
       <p>
        This is the hiding of info by keeping member data, or whatever else is not part of the interface (implementation details), private in your classes.  The benefit of this is that you are free to change the implementation without affecting clients (except for causing a recompile, possibly).
       </p>
       <h2>
       </h2>
       <p>
        <a href="http://www.parashift.com/c++-faq-lite/classes-and-objects.html#faq-7.4">
         C++ Faq Lite on encapsulation
        </a>
       </p>
      </dd>
      <dt id="polymorphism">
       Polymorphism
      </dt>
      <dd>
       <p>
        The ability to manipulate various different objects via a common base class pointer.  This is supposed to keep your code generic, methinks, by encouraging you to design an interface for your base class and then implement that interface in the derived classes, and then manipulate those objects using a pointer or reference to the base class.
       </p>
      </dd>
      <dt id="inheritance">
       Inheritance
      </dt>
      <dd>
       <p>
        Commonly thought of as a way to "reuse existing code" by creating a new class that inherits from another existing class.  This way you can extend the functionality of an existing class w/o touching the existing class's code.  But Herb Sutter has a bit of a different take on the use of inheritance--"Inherit, not to reuse, but to be reused.  Don't inherit publicly to reuse code (that exists in the base class); inherit publicly in order to be reused (by existing code that already uses base objects polymorphically)." [C++ Coding Standards, p. 64].  He also says "In correct inheritance, a derived class models a special case of a more general base concept." [ibid, p. 66]
       </p>
       <p>
        Should model "is-a".
       </p>
       <p>
        There are also weird things like protected and private inheritance.  I have never seen these in use.
       </p>
       <h2>
       </h2>
       <p>
        <a href="http://www.parashift.com/c++-faq-lite/basics-of-inheritance.html">
         C++ Faq Lite on inheritance
        </a>
       </p>
      </dd>
      <dt id="virtual">
       Virtual
      </dt>
      <dd>
       <p>
        This is what allows inheritance to work.  If you declare a function virtual, you can override that function in a derived class.  Then a pointer to a base class can do different stuff (polymorphism).
       </p>
       <h2>
        Make destructors virtual in base classes
       </h2>
       <p>
        This is so that deleting a pointer to a base class which really points to a derived-class object calls the proper chain of destructors.  If you don't declare the destructor virtual, the base class destructor is the only that will be called.  If you do declare the destructor virtual, then the destructors are chained from most-derived on down to base, which is what you want of course.
       </p>
      </dd>
      <dt id="const">
       Const
      </dt>
      <dd>
       <p>
        As Scott Meyers says, "Use const whenever possible".  I agree with this because making something const removes that thing from the giant list of things you have to think about.  When you are reading new code and trying to make sense of it, it helps to winnow down the amount of stuff you have to keep in your head all at once.
       </p>
       <p>
        You can make various things const.
       </p>
       <ul>
        <li>
         <p>
          <em>
           data members
          </em>
          --just declare them const in the class declaration.  You will have to initialize them in the
          <a href="#initializer-list">
           constructor initializer list
          </a>
          since a const cannot be changed once it is set.  So you can never write
          <code>
           x = y;
          </code>
          if x is declared const.  You can only write
          <code>
           const int x = y;
          </code>
          This presents a problem for data members, so the only way to initialize a const data member is via the
          <a href="#initializer-list">
           constructor initializer list
          </a>
          .
         </p>
        </li>
        <li>
         <p>
          <em>
           pointers
          </em>
          --these are tricky because there are two pointer things that can be const--the pointer itself, and the thing the pointer points to.  The syntax is different in each case.
         </p>
         <p>
          To make the pointer itself const:
          <code>
           char* const p = "abc";
          </code>
         </p>
         <p>
          To make the thing pointed to const:
          <code>
           const char* p = "abc";
          </code>
         </p>
         <p>
          To make both const:
          <code>
           const char* const p = "abc";
          </code>
         </p>
        </li>
        <li>
         <p>
          <em>
           member functions
          </em>
          --make class member functions by adding const after the declaration and definition (it's part of the function signature).  A const member function is useful because it tells you "I won't change anything in the class (i.e., I won't change any class member values, i.e., I won't call any non-const member functions)"  Or put another way, "I can only be called on const objects".  This is known as
          <strong>
           const correctness
          </strong>
          .  Another way to think of it: in a non-const member function, the
          <code>
           this
          </code>
          pointer for a class 'C' acts as if it's declared
          <code>
           C* const this;
          </code>
          , inside a const member function, the
          <code>
           this
          </code>
          pointer acts like
          <code>
           const C* const this;
          </code>
         </p>
        </li>
       </ul>
       <h2>
        Mutable
       </h2>
       <p>
        This keyword is used to un-const something, so that it can be changed by a const function.  Things get a little sticky here regarding the definition of const for a class.  If you feel like you can safely change some internal class member yet the class object still retains some "constness" to the outside world, you need to declare that particular member as mutable.  Otherwise, your code won't compile (you can't modify data members in a const function............unless they are mutable!).
       </p>
       <h2>
       </h2>
       <p>
        <a href="http://www.parashift.com/c++-faq-lite/const-correctness.html">
         C++ Faq Lite on const
        </a>
       </p>
      </dd>
      <dt id="compiler-generated-functions">
       What class functions does the compiler write for you?
      </dt>
      <dd>
       <h2>
        Default Constructor
       </h2>
       <p>
        The compiler will write this for you only if you have no other constructors declared.  The one generated by the compiler does nothing.
       </p>
       <h2>
        Copy Constructor
       </h2>
       <p>
        You'll get one of these only if needed.  The compiler-generated version will do bitwise copy.  How do you know if a copy constructor is needed?  If you pass your class object by value to a function, that will generate a call to the copy constructor.  If you initialize from another object, that calls the copy constructor.  Eg.
        <code>
         C c;
C c2(c); // copy constructor called.
C c3 = c; // copy constructor called.
        </code>
        Sometimes there can be confusion between when a copy constructor and an assignment operator are invoked.  If the statement contains the creation of a new object, then the copy constructor is invoked, even when you see an '=', as in the creation of c3 above.
       </p>
       <h2>
        Assignment Operator
       </h2>
       <p>
        You'll get one of these only if needed.  The compiler-generated version will do bitwise copy.
        <code>
         C c;
C c2;
c = c2; // assignment operator called.
        </code>
       </p>
       <h2>
        Other Stuff
       </h2>
       <p>
        C++ will also generate some address-of operators for you.  You don't need to know this.
       </p>
      </dd>
      <dt id="multiple-inheritance">
       Multiple Inheritance
      </dt>
      <dd>
       <p>
        Everyone recommends avoiding MI, so follow that advice.  You can get into messy situations, such as the object having multiple versions of the same base object, etc.  I get a headache even thinking about most of it.  Not worth it.
       </p>
      </dd>
      <dt id="initializer-list">
       Constructor Initializer List
      </dt>
      <dd>
       <p>
        This is the thing after the colon before a constructor body.  As in
        <code>
         MyClass::MyClass(int x)
         <strong>
          : c(x)
         </strong>
         {
  ...
}
        </code>
        The constructor initializer list is the
        <em>
         only
        </em>
        way to initialize reference members and consts.  It is also the only way to pass parameters to constructors of sub objects (either base classes or member objects).  It's also good to use it to invoke member copy constructors to avoid default construction of those objects followed by assignment, although maybe compilers nowadays optimize this away anyhow.
       </p>
      </dd>
      <dt id="abc">
       Abstract Base Class ("ABC")
      </dt>
      <dd>
       <h2>
        What is it?
       </h2>
       <p>
        It's an interface definition.  It's a class that you cannot instantiate.  Its purpose is to serve as the base class for other classes you will derive from it, and it defines a common interface (set of class methods) that all instances must implement.
       </p>
       <h2>
        How do you create one?
       </h2>
       <p>
        You indicate that a class is an ABC by setting one or more of its functions "= 0", which turns that function into a "pure virtual function".  This is kind of a hackish syntax.  Example:
        <code>
         class ABC
{
  ...
  virtual function()
         <strong>
          = 0
         </strong>
         ;
  ...
};
        </code>
       </p>
       <p>
        Only one function in a class needs to be declared pure virtual to make the class abstract.
       </p>
       <p>
        You may be asked in an interview whether you can define a function body for a pure virtual function.  The answer is
        <strong>
         yes
        </strong>
        .  Just as in a regular base class, you can define common functionality in an ABC, even in functions marked as pure virtual.  There seems to be common confusion with respect to this.  The only thing you can't do with an ABC is instantiate objects of the class.
       </p>
       <h2>
       </h2>
       <p>
        <a href="http://www.parashift.com/c++-faq-lite/abcs.html">
         C++ Faq Lite on abstract base classes
        </a>
       </p>
      </dd>
      <dt id="big-o">
       Big O Notation
      </dt>
      <dd>
       <p>
        This is a way to indicate the relationship between the time an operation will take and the number of items being operated on (dataset size).
       </p>
       <p>
        These are some you should be familiar with, methinks.
       </p>
       <h2>
        O(1)
       </h2>
       <p>
        Constant time.  Time to do the computation does not depend at all on the number of items being operated on.
       </p>
       <h2>
        O(n)
       </h2>
       <p>
        This means "linear time", aka "the time the operation will take is directly proportional to the number of items being operated on".  An example is a search through an unsorted list.  The only way to do it is look through the list item by item.
       </p>
       <h2>
        O(n-squared)
       </h2>
       <p>
        This means whatever you are doing will take a long time--not good.
       </p>
       <h2>
        O(log(n))
       </h2>
       <p>
        Just mumble something about "binary trees" and you'll be fine.
       </p>
      </dd>
     </dl>
    </div>
    <!-- content -->
    <div id="ads">
     <div id="gads">
      <script type="text/javascript">
       &lt;!--
google_ad_client = "pub-1341213044095907";
//160x600, created 1/9/08
google_ad_slot = "1317522410";
google_ad_width = 160;
google_ad_height = 600;
//--&gt;
      </script>
      <script src="http://pagead2.googlesyndication.com/pagead/show_ads.js" type="text/javascript">
      </script>
     </div>
    </div>
    <!-- ads -->
   </div>
   <!-- main -->
   <div id="footer">
    <p>
     Please visit our other fine reference site, on the joys of Python programming vs. the misery of Perl, at
     <a href="http://strombergers.com/python/">
      http://strombergers.com/python/
     </a>
    </p>
   </div>
   <!-- footer -->
  </div>
  <!-- outer -->
 </body>
</html>