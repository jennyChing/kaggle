<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <title>
   C++ Socket Class for Windows
  </title>
  <style type="text/css">
   &lt;!--
  body {
    margin-left:   0px;
    margin-right:  0px;
    margin-top:    0px;
    font-family:   verdana, helvetica, sans-serif;
    font-size:     12px;
  } 
	
  h1 {
    color:#4274c2;
    font-size: 22px;
    margin-left: 0px;
    margin-top: 25px;
    font-family: monospace;
  }
  h2 {
    color:        #4274c2;
    font-size:    18px;
    margin-left:   0px;
    font-family: monospace;
    margin-bottom: 5px;
  }
  h3 {
    color:#4274c2;
    font-size: 16px;
    margin-left:  10px;
    font-family: monospace;
    margin-bottom: 2px;
  }
  h4 {
    color:#4274c2;
    font-size: 12px;
    margin-left:  20px;
    font-family: monospace;
    margin-bottom: 2px;
  }
  a {
    color:#553333;  
  }
  div.header a {
    color:#eeeecc;
  }
  div.header {
    color:#eeeecc;
  }
  div.footer {
    margin-left: 6px;
    margin-bottom: 1000px;
  }
  pre.code b {
    color:#000000;
  }
  pre.out b {
    color:#000000;
  }
  pre.code   {
	  background-color:#f6f9e3;
	  color:#10205f;
	  padding-left:10px; 
	  padding-right:10px; 
    padding-top:5px;
    padding-bottom:5px;
    margin-top:2px;
  	border:1px solid #004080;
    margin-left:20px;
  }
  pre.out    {
	  background-color:#ebf6f9;
	  color:#000000;
	  padding-left:10px; 
	  padding-right:10px; 
    padding-top:5px;
    padding-bottom:2px;
    margin-top:2px;
    margin-left:20px;
  	border:1px solid #b09040;
  }
  pre.syn    {
	  background-color:#efe9cf;
	  color:#000000;
	  padding-left:10px; 
	  padding-right:10px; 
    padding-top:5px;
    padding-bottom:2px;
    margin-top:2px;
    margin-left:20px;
  	border:1px solid #4090b0;
  }
  pre.syn b {
    color:#000000;
  }
  pre {
    padding:        0px; 
    margin-top:     6px;
    margin-bottom: 14px;
    margin-left:   20px;
  }
  div.quote    {
    margin-left:40px;
    margin-right:40px;
    border:1px dotted #e0e0c0;
    background-color: #d5e5c5;
    font-size:11px;
  }
  div.small    {
    padding-left:40px;
    padding-top:10px;
    font-size:9px;
  }
  div.txt {
    width:        400px;
    margin-bottom:9px;
    margin-left:20px;
  }
  div.txt_wide {
    margin-bottom:9px;
    margin-left:20px;
  }
  img.img {
    margin-left:20px;
  }
  img.img0 {
    margin-left:0px;
  }
  body table tr td table {
    margin-left:20px;
  }
  div.filename {
    font-size:10px;
    font-style:italic;
    margin-left:20px;
  }
  form {
    margin-left:20px;
  }
  table {
    margin-bottom:9px;
  }

  ul {margin-top:1px;margin-bottom:9px;}
  ol {margin-top:1px;margin-bottom:9px;}
  li {margin-bottom: 2px}

  
--&gt;
  </style>
 </head>
 <body bgcolor="#eeeecc" onload="if (self != top) top.location = self.location;" text="#000000">
  <div class="header">
   <table bgcolor="#4274c2" summary="header" width="100%">
    <tr>
     <td>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td width="202">
     </td>
     <td style="font-size:17px">
      Ren Nyffenegger's collection of things on the web
     </td>
    </tr>
    <tr>
     <td>
     </td>
     <td>
      <a href="http://www.adp-gmbh.ch/">
       Ren Nyffenegger on Oracle
      </a>
      -
      <a href="http://www.adp-gmbh.ch/misc/most_wanted.html">
       Most wanted
      </a>
      -
      <a href="http://www.adp-gmbh.ch/feedback.html">
       Feedback
      </a>
      -
      <a class="twitter-follow-button" data-show-count="false" href="https://twitter.com/renenyffenegger">
       Follow @renenyffenegger
      </a>
      <script>
       !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
      </script>
      <br/>
     </td>
    </tr>
   </table>
  </div>
  <table border="0" cellpadding="0" cellspacing="0" summary="layout table" width="100%">
   <tr valign="top">
    <td width="162">
    </td>
    <td width="25">
    </td>
    <td>
     <h1>
      C++ Socket Class for Windows
     </h1>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <script type="text/javascript">
      &lt;!--
google_ad_client = "pub-8899454244071340";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_channel ="7026387021";
google_color_border = "EEEECC";
google_color_bg = "EEEECC";
google_color_link = "0000FF";
google_color_url = "008000";
google_color_text = "0000CC";
//--&gt;
     </script>
     <script src="http://pagead2.googlesyndication.com/pagead/show_ads.js" type="text/javascript">
     </script>
     <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
     </script>
     <script type="text/javascript">
      _uacct = "UA-221075-1";
urchinTracker();
     </script>
    </td>
    <td>
    </td>
    <td>
     <div class="txt">
      Here, I present the source code for a
      <span class="keyword">
       socket class
      </span>
      that faciliates using Sockets in Windows Programming. I also
   want to say thanks
      <b>
       Fabien Le Lez
      </b>
      ,
      <a href="http://www.infflux.com">
       www.infflux.com
      </a>
      and
      <b>
       Tamas Kaskoto
      </b>
      who have improved this source.
     </div>
     <div class="txt">
      This socket class is being used for
      <a href="http://www.hartwork.org/">
       BROADCAST chat client
      </a>
      .
     </div>
     <div class="txt">
      These are actually four classes:
      <b>
       Socket
      </b>
      (the base class) from which
      <b>
       SocketServer
      </b>
      and
      <b>
       SocketClient
      </b>
      are derived. Also,
   there is
      <b>
       SocketSelect
      </b>
      which can be used to do a Select call on more than one Socket. The
   constructors of Socket are protected; this should be a taken as a hint not to use Socket, but either SocketServer or SocketClient.
     </div>
     <div class="txt">
      When you compile this files, make sure you link them against
      <b>
       Ws2_32.lib
      </b>
      .
     </div>
     <div class="txt">
      Jump to the
      <a href="#header">
       header file
      </a>
      , the
      <a href="#implementation">
       implementation file
      </a>
      , the
      <a href="#test">
       test programm
      </a>
      and the
      <a href="#echo">
       Echo Server
      </a>
      . Here's also a
      <a href="#proxy">
       Proxy
      </a>
      and a
      <a href="webserver.html">
       Web Server
      </a>
      .
     </div>
     <div class="txt">
      You can also
      <a href="#download">
       download the files
      </a>
      .
     </div>
     <div class="txt">
      A small description of the socket class: 
     Every program that uses Windows Sockets needs to call
      <b>
       WSAStartup
      </b>
      . This call is wrapped into
      <b>
       Socket::Start
      </b>
      , which in turn is called by
     the Socket's constructor. I pass 2.0 as version here as I expect that version to be installed.
      <br/>
      The Socket's constructor also calls
      <i>
       socket()
      </i>
      (note the small s) which actually creates the socket. It passes the
      <b>
       SOCK_STREAM
      </b>
      parameter, 
     indicating TCP.  If UDP were wished, you'd have to pass
      <b>
       SOCK_DGRAM
      </b>
      .
     </div>
     <div class="txt">
      <b>
       SocketClient
      </b>
      : SocketClient is inherited from Socket.
      <br/>
      The constructor of SocketClient takes a
      <b>
       host
      </b>
      as parameter, which is the name of the server that this client wishes to communicate to.
     This name is resolved into an IP Address by
      <i>
       gethostbyname()
      </i>
      .
     </div>
     <div class="txt">
      <b>
       SocketServer
      </b>
      : SocketServer is inherited from Socket.
      <br/>
      The constructor of the SocketServer class listens on the port indicated in its parameter. This is made by calling
      <i>
       bind()
      </i>
      .
      <br/>
      As SOCK_STREAM type sockets have the ability to queue incoming connection requests, we need to know the maximum number of connections
     to be queued which can be stated by the
      <b>
       connections
      </b>
      parameter (and which is passed to
      <i>
       listen()
      </i>
      ).
      <br/>
      SocketServer::
      <b>
       Accept()
      </b>
      : simply waits for an incoming connection request (or removes one from the queue) by calling
      <b>
       accept
      </b>
      (note the small a).
     </div>
     <h3 id="header">
      The header file
     </h3>
     <div class="filename">
      socket.h
     </div>
     <div>
      <pre class="code">
       /* 
   Socket.h

   Copyright (C) 2002-2004 Ren Nyffenegger

   This source code is provided 'as-is', without any express or implied
   warranty. In no event will the author be held liable for any damages
   arising from the use of this software.

   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:

   1. The origin of this source code must not be misrepresented; you must not
      claim that you wrote the original source code. If you use this source code
      in a product, an acknowledgment in the product documentation would be
      appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
      misrepresented as being the original source code.

   3. This notice may not be removed or altered from any source distribution.

   Ren Nyffenegger rene.nyffenegger@adp-gmbh.ch
*/

#ifndef SOCKET_H
#define SOCKET_H

#include &lt;WinSock2.h&gt;

#include &lt;string&gt;

enum TypeSocket {BlockingSocket, NonBlockingSocket};

class
       <b>
        Socket
       </b>
       {
public:

  virtual ~Socket();
  Socket(const Socket&amp;);
  Socket&amp; operator=(Socket&amp;);

  std::string ReceiveLine();
  std::string ReceiveBytes();

  void   Close();

  // The parameter of SendLine is not a const reference
  // because SendLine modifes the std::string passed.
  void   SendLine (std::string);

  // The parameter of SendBytes is a const reference
  // because SendBytes does not modify the std::string passed 
  // (in contrast to SendLine).
  void   SendBytes(const std::string&amp;);

protected:
  friend class SocketServer;
  friend class SocketSelect;

  Socket(SOCKET s);
  Socket();


  SOCKET s_;

  int* refCounter_;

private:
  static void Start();
  static void End();
  static int  nofSockets_;
};
       <a name="class_socketclient">
       </a>
       class
       <b>
        SocketClient
       </b>
       : public Socket {
public:
  SocketClient(const std::string&amp; host, int port);
};
       <a name="class_socketserver">
       </a>
       class
       <b>
        SocketServer
       </b>
       : public Socket {
public:
  SocketServer(int port, int connections, TypeSocket type=BlockingSocket);

  Socket*
       <a href="#accpet">
        Accept
       </a>
       ();
};

// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winsock/wsapiref_2tiq.asp
class SocketSelect {
  public:
    SocketSelect(Socket const * const s1, Socket const * const s2=NULL, TypeSocket type=BlockingSocket);

    bool Readable(Socket const * const s);

  private:
    fd_set fds_;
}; 



#endif
      </pre>
     </div>
     <h3 id="implementation">
      The implementation file
     </h3>
     <div class="filename">
      socket.cpp
     </div>
     <div>
      <pre class="code">
       /* 
   Socket.cpp

   Copyright (C) 2002-2004 Ren Nyffenegger

   This source code is provided 'as-is', without any express or implied
   warranty. In no event will the author be held liable for any damages
   arising from the use of this software.

   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:

   1. The origin of this source code must not be misrepresented; you must not
      claim that you wrote the original source code. If you use this source code
      in a product, an acknowledgment in the product documentation would be
      appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
      misrepresented as being the original source code.

   3. This notice may not be removed or altered from any source distribution.

   Ren Nyffenegger rene.nyffenegger@adp-gmbh.ch
*/


#include "Socket.h"
#include &lt;iostream&gt;

using namespace std;

int Socket::nofSockets_= 0;
       <a name="start">
       </a>
       void
       <b>
        Socket::Start
       </b>
       () {
  if (!nofSockets_) {
    WSADATA info;
    if (WSAStartup(MAKEWORD(2,0), &amp;info)) {
      throw "Could not start WSA";
    }
  }
  ++nofSockets_;
}
       <a name="end">
       </a>
       void
       <b>
        Socket::End
       </b>
       () {
  WSACleanup();
}
       <b>
        Socket::Socket
       </b>
       () : s_(0) {
       <a href="#start">
        Start
       </a>
       ();
  // UDP: use SOCK_DGRAM instead of SOCK_STREAM
  s_ = socket(AF_INET,SOCK_STREAM,0);

  if (s_ == INVALID_SOCKET) {
    throw "INVALID_SOCKET";
  }

  refCounter_ = new int(1);
}
       <b>
        Socket::Socket
       </b>
       (SOCKET s) : s_(s) {
       <a href="#start">
        Start
       </a>
       ();
  refCounter_ = new int(1);
};
       <b>
        Socket::~Socket
       </b>
       () {
  if (! --(*refCounter_)) {
    Close();
    delete refCounter_;
  }

  --nofSockets_;
  if (!nofSockets_) End();
}
       <b>
        Socket::Socket
       </b>
       (const Socket&amp; o) {
  refCounter_=o.refCounter_;
  (*refCounter_)++;
  s_         =o.s_;

  nofSockets_++;
}

Socket&amp;
       <b>
        Socket::operator=
       </b>
       (Socket&amp; o) {
  (*o.refCounter_)++;

  refCounter_=o.refCounter_;
  s_         =o.s_;

  nofSockets_++;

  return *this;
}
       <a name="close">
       </a>
       void
       <b>
        Socket::Close
       </b>
       () {
  closesocket(s_);
}
       <a name="receivebytes">
       </a>
       std::string
       <b>
        Socket::ReceiveBytes
       </b>
       () {
  std::string ret;
  char buf[1024];
 
  while (1) {
    u_long arg = 0;
    if (ioctlsocket(s_, FIONREAD, &amp;arg) != 0)
      break;

    if (arg == 0)
      break;

    if (arg &gt; 1024) arg = 1024;

    int rv = recv (s_, buf, arg, 0);
    if (rv &lt;= 0) break;

    std::string t;

    t.assign (buf, rv);
    ret += t;
  }
 
  return ret;
}
       <a name="receiveline">
       </a>
       std::string
       <b>
        Socket::ReceiveLine
       </b>
       () {
  std::string ret;
  while (1) {
    char r;

    switch(recv(s_, &amp;r, 1, 0)) {
      case 0: // not connected anymore;
              // ... but last line sent
              // might not end in \n,
              // so return ret anyway.
        return ret;
      case -1:
        return "";
//      if (errno == EAGAIN) {
//        return ret;
//      } else {
//      // not connected anymore
//      return "";
//      }
    }

    ret += r;
    if (r == '\n')  return ret;
  }
}
       <a name="sendline">
       </a>
       void
       <b>
        Socket::SendLine
       </b>
       (std::string s) {
  s += '\n';
  send(s_,s.c_str(),s.length(),0);
}
       <a name="sendbytes">
       </a>
       void
       <b>
        Socket::SendBytes
       </b>
       (const std::string&amp; s) {
  send(s_,s.c_str(),s.length(),0);
}

SocketServer::SocketServer(int port, int connections, TypeSocket type) {
  sockaddr_in sa;

  memset(&amp;sa, 0, sizeof(sa));

  sa.sin_family = PF_INET;             
  sa.sin_port = htons(port);          
  s_ = socket(AF_INET, SOCK_STREAM, 0);
  if (s_ == INVALID_SOCKET) {
    throw "INVALID_SOCKET";
  }

  if(type==NonBlockingSocket) {
    u_long arg = 1;
    ioctlsocket(s_, FIONBIO, &amp;arg);
  }

  /* bind the socket to the internet address */
  if (bind(s_, (sockaddr *)&amp;sa, sizeof(sockaddr_in)) == SOCKET_ERROR) {
    closesocket(s_);
    throw "INVALID_SOCKET";
  }
  
  listen(s_, connections);                               
}
       <a name="accept">
       </a>
       Socket*
       <b>
        SocketServer::Accept
       </b>
       () {
  SOCKET new_sock = accept(s_, 0, 0);
  if (new_sock == INVALID_SOCKET) {
    int rc = WSAGetLastError();
    if(rc==WSAEWOULDBLOCK) {
      return 0; // non-blocking call, no request pending
    }
    else {
      throw "Invalid Socket";
    }
  }

  Socket* r = new Socket(new_sock);
  return r;
}
       <b>
        SocketClient::SocketClient
       </b>
       (const std::string&amp; host, int port) : Socket() {
  std::string error;

  hostent *he;
  if ((he = gethostbyname(host.c_str())) == 0) {
    error = strerror(errno);
    throw error;
  }

  sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  addr.sin_addr = *((in_addr *)he-&gt;h_addr);
  memset(&amp;(addr.sin_zero), 0, 8); 

  if (::connect(s_, (sockaddr *) &amp;addr, sizeof(sockaddr))) {
    error = strerror(WSAGetLastError());
    throw error;
  }
}
       <b>
        SocketSelect::SocketSelect
       </b>
       (Socket const * const s1, Socket const * const s2, TypeSocket type) {
  FD_ZERO(&amp;fds_);
  FD_SET(const_cast&lt;Socket*&gt;(s1)-&gt;s_,&amp;fds_);
  if(s2) {
    FD_SET(const_cast&lt;Socket*&gt;(s2)-&gt;s_,&amp;fds_);
  }     

  TIMEVAL tval;
  tval.tv_sec  = 0;
  tval.tv_usec = 1;

  TIMEVAL *ptval;
  if(type==NonBlockingSocket) {
    ptval = &tval;
  }
  else { 
    ptval = 0;
  }

  if (select (0, &amp;fds_, (fd_set*) 0, (fd_set*) 0, ptval) == SOCKET_ERROR) 
    throw "Error in select";
}

bool
       <b>
        SocketSelect::Readable
       </b>
       (Socket const* const s) {
  if (FD_ISSET(s-&gt;s_,&amp;fds_)) return true;
  return false;
}
      </pre>
     </div>
     <h2 id="test">
      A simple Client
     </h2>
     <div class="txt">
      The following simple client connects to
      <b>
       www.google.ch
      </b>
      and get its front-website.
     </div>
     <div>
      <pre class="code">
       #include "Socket.h"

#include &lt;iostream&gt;

using namespace std;

int main() {

  try {
    SocketClient s("www.google.com", 80);

    s.SendLine("GET / HTTP/1.0");
    s.SendLine("Host: www.google.com");
    s.SendLine("");

    while (1) {
      string l = s.ReceiveLine();
      if (l.empty()) break;
      cout &lt;&lt; l;
      cout.flush();
    }

  } 
  catch (const char* s) {
    cerr &lt;&lt; s &lt;&lt; endl;
  } 
  catch (std::string s) {
    cerr &lt;&lt; s &lt;&lt; endl;
  } 
  catch (...) {
    cerr &lt;&lt; "unhandled exception\n";
  }

  return 0;
}
      </pre>
     </div>
     <h2 id="echo">
      A simple echo Server
     </h2>
     <div class="txt">
      The following simple Server opens a port on 2000 and waits for incoming connections.  Each connection is answered with the same line as was written (echoed).
     </div>
     <div class="txt">
      If you want to test the server, use
      <code>
       telnet localhost 2000
      </code>
     </div>
     <div>
      <pre class="code">
       /* 
   EchoServer.cpp

   Copyright (C) 2002-2004 Ren Nyffenegger

   This source code is provided 'as-is', without any express or implied
   warranty. In no event will the author be held liable for any damages
   arising from the use of this software.

   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:

   1. The origin of this source code must not be misrepresented; you must not
      claim that you wrote the original source code. If you use this source code
      in a product, an acknowledgment in the product documentation would be
      appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
      misrepresented as being the original source code.

   3. This notice may not be removed or altered from any source distribution.

   Ren Nyffenegger rene.nyffenegger@adp-gmbh.ch
*/


#include "
       <a href="http://www.adp-gmbh.ch/win/misc/sockets.html#header">
        Socket.h
       </a>
       "
#include &lt;process.h&gt;
#include &lt;string&gt;
       <a name="answer">
       </a>
       unsigned __stdcall
       <b>
        Answer
       </b>
       (void* a) {
  Socket* s = (Socket*) a;

  while (1) {
    std::string r = s-&gt;
       <a href="http://www.adp-gmbh.ch/win/misc/sockets.html#receiveline">
        ReceiveLine
       </a>
       ();
    if (r.empty()) break;
    s-&gt;
       <a href="http://www.adp-gmbh.ch/win/misc/sockets.html#sendline">
        SendLine
       </a>
       (r);
  }

  delete s;

  return 0;
}

int
       <b>
        main
       </b>
       (int argc, char* argv[]) {
       <a href="#class_socketserver">
        SocketServer
       </a>
       in(2000,5);

  while (1) {
    Socket* s=in.
       <a href="http://www.adp-gmbh.ch/win/misc/sockets.html#accpets">
        Accept
       </a>
       ();

    unsigned ret;
    _beginthreadex(0,0,Answer,(void*) s,0,&amp;ret);
  }
 
  return 0;
}
      </pre>
     </div>
     <h2 id="proxy">
      A Proxy that uses the Socket class
     </h2>
     <div class="txt">
      You need the
      <a href="../../cpp/chameleon.html">
       Chameleon
      </a>
      class to compile this proxy.
     </div>
     <div class="txt">
      <b>
       Usage:
      </b>
      <code>
       proxy  &lt;port proxy&gt; &lt;addr server&gt; &lt;port server&gt;
      </code>
      .
      <br/>
      This proxy will then listen on &lt;port proxy&gt; and whenever it receives
  a connection, relays the traffic to the &lt;port server&gt; of &lt;addr server&gt;.
  This makes it ideal to see what an SMTP Client exchanges with a SMTP Server,
  or equally what a NNTP client exchanges with an NNTP Server.
     </div>
     <div class="filename">
      Proxy.cpp
     </div>
     <div>
      <pre class="code">
       /* 
   Proxy.cpp

   Copyright (C) 2002-2004 Ren Nyffenegger

   This source code is provided 'as-is', without any express or implied
   warranty. In no event will the author be held liable for any damages
   arising from the use of this software.

   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:

   1. The origin of this source code must not be misrepresented; you must not
      claim that you wrote the original source code. If you use this source code
      in a product, an acknowledgment in the product documentation would be
      appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
      misrepresented as being the original source code.

   3. This notice may not be removed or altered from any source distribution.

   Ren Nyffenegger rene.nyffenegger@adp-gmbh.ch
*/

#include "
       <a href="http://www.adp-gmbh.ch/win/misc/sockets.html#header">
        Socket.h
       </a>
       "

#include &lt;iostream&gt;
#include &lt;process.h&gt;
#include &lt;sstream&gt;

int         portProxy;
std::string addrServer;
int         portServer;
       <a name="runproxythread">
       </a>
       unsigned __stdcall
       <b>
        RunProxyThread
       </b>
       (void* a) {
  Socket*      s = (Socket*) a;
  SocketClient c(addrServer, portServer);

  while (1) {
    SocketSelect sel(s, &amp;c);

    bool still_connected = true;

    if (sel.Readable(s)) {
      std::string bytes = s-&gt;ReceiveBytes();
      c.SendBytes(bytes);
      std::cout &lt;&lt; "Server: " &lt;&lt; bytes &lt;&lt; std::endl;
      if (bytes.empty()) still_connected=false;
    }
    if (sel.Readable(&amp;c)) {
      std::string bytes = c.ReceiveBytes();
      s-&gt;SendBytes(bytes);
      std::cout &lt;&lt; "Client: " &lt;&lt; bytes &lt;&lt; std::endl;
      if (bytes.empty()) still_connected=false;
    }
    if (! still_connected) {
      break;
    }
  }

  delete s;

  return 0;
}

int
       <b>
        main
       </b>
       (int argc, char* argv[]) {
  if (argc &lt; 4) {
    std::cout &lt;&lt; "Usage:" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  proxy &lt;port proxy&gt; &lt;addr server&gt; &lt;port server&gt;" &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; "  This proxy will then listen on &lt;port proxy&gt; and whenever it receives" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  a connection, relays the traffic to the &lt;port server&gt; of &lt;addr server&gt;." &lt;&lt; std::endl;
    std::cout &lt;&lt; "  This makes it ideal to see what an SMTP Client exchanges with a SMTP Server," &lt;&lt; std::endl;
    std::cout &lt;&lt; "  or equally what a NNTP client exchanges with an NNTP Server." &lt;&lt; std::endl &lt;&lt; std::endl;
    return -1;
  }

  std::stringstream s; 
  
  s&lt;&lt;argv[1]; s&gt;&gt;portProxy; s.clear();

  addrServer=argv[2];

  s&lt;&lt;argv[3]; s&gt;&gt;portServer;

  SocketServer in(portProxy,5);

  while (1) {
    Socket* s=in.Accept();

    unsigned ret;
    _beginthreadex(0, 0,
       <a href="#runproxythread">
        RunProxyThread
       </a>
       ,(void*) s,0,&amp;ret);
  }
  
  return 0;
}
      </pre>
     </div>
     <div class="txt">
      See also:
      <a href="http://www.fiddlertool.com/fiddler/">
       Fiddler
      </a>
      : 
  a HTTP Debugging Proxy which logs all HTTP traffic between your
  computer and the Internet. Fiddler allows you to watch HTTP Traffic, set
  breakpoints, and "fiddle" with incoming or outgoing data. Fiddler is designed
  to be much simpler than using NetMon or Achilles.
     </div>
     <h2>
      Message Distributor
     </h2>
     <div class="txt">
      Message Distributor is a server that listens on port 2000. Any number of clients can connect to that server. When a client sends
  a message to the server, the server will broadcast this message to all other clients, but not to the one that sent the message.
     </div>
     <div class="filename">
      MsgDistributor.cpp
     </div>
     <div>
      <pre class="code">
       /* 
   MsgDistributor.cpp

   Copyright (C) 2002-2004 Ren Nyffenegger

   This source code is provided 'as-is', without any express or implied
   warranty. In no event will the author be held liable for any damages
   arising from the use of this software.

   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:

   1. The origin of this source code must not be misrepresented; you must not
      claim that you wrote the original source code. If you use this source code
      in a product, an acknowledgment in the product documentation would be
      appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
      misrepresented as being the original source code.

   3. This notice may not be removed or altered from any source distribution.

   Ren Nyffenegger rene.nyffenegger@adp-gmbh.ch
*/

#include "
       <a href="http://www.adp-gmbh.ch/win/misc/sockets.html#header">
        Socket.h
       </a>
       "
#include &lt;process.h&gt;
#include &lt;string&gt;
#include &lt;list&gt;

typedef std::list&lt;Socket*&gt; socket_list;

socket_list g_connections;

unsigned __stdcall Connection(void* a) {
  Socket* s = (Socket*) a;

  g_connections.push_back(s);

  s-&gt;
       <a href="http://www.adp-gmbh.ch/win/misc/sockets.html#sendline">
        SendLine
       </a>
       ("Welcome to the Message Distributor");

  while (1) {
    std::string r = s-&gt;
       <a href="http://www.adp-gmbh.ch/win/misc/sockets.html#receiveline">
        ReceiveLine
       </a>
       ();
    if (r.empty()) break;

    for (socket_list::iterator os =g_connections.begin();
                               os!=g_connections.end(); 
                               os++) {
      if (*os != s) (*os)-&gt;
       <a href="http://www.adp-gmbh.ch/win/misc/sockets.html#sendline">
        SendLine
       </a>
       (r);
    }
  }

  g_connections.remove(s);

  delete s;

  return 0;
}

int main() {
       <a href="http://www.adp-gmbh.ch/win/misc/sockets.html#class_socketserver">
        SocketServer
       </a>
       in(2000,5);
  
  while (1) {
    Socket* s=in.
       <a href="http://www.adp-gmbh.ch/win/misc/sockets.html#accept">
        Accept
       </a>
       ();
  
    unsigned ret;
    _beginthreadex(0,0,Connection,(void*) s,0,&amp;ret);
  }
  
  return 0;
}
      </pre>
     </div>
     <h2 id="download">
      Download the files
     </h2>
     <div class="txt">
      You can download the source code and the exefiles as a
      <a href="socket.zip">
       zip file
      </a>
      consisting of
      <ul>
       <li>
        socket.h
       </li>
       <li>
        Chameleon.h
       </li>
       <li>
        Chameleon.cpp
       </li>
       <li>
        EchoServer.cpp
       </li>
       <li>
        MsgDistributor.cpp
       </li>
       <li>
        Proxy.cpp
       </li>
       <li>
        Socket.cpp
       </li>
       <li>
        EchoServer.exe
       </li>
       <li>
        Proxy.exe
       </li>
       <li>
        makefile
       </li>
      </ul>
      I was able to compile the sources with
      <a href="http://www.adp-gmbh.ch/win/misc/mingw/index.html">
       mingw
      </a>
      using the supplied makefile.
     </div>
     <h2>
      Thanks
     </h2>
     <div class="txt">
      Thanks to
      <b>
       Eugene Wee
      </b>
      and
      <b>
       Nathan Vander Wilt
      </b>
      who helped me improve the socket class.
     </div>
    </td>
   </tr>
  </table>
  <hr/>
  <div class="footer">
  </div>
 </body>
</html>