<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml">
 <head profile="http://gmpg.org/xfn/11">
  <meta content="IE=EmulateIE7" http-equiv="X-UA-Compatible"/>
  <meta content="_bcsv5C0d_g2I2rptTyqb4DzcmIaZpysMS4DNut_vJ8" name="google-site-verification"/>
  <title>
   Embedded in Academia : Nine ways to break your systems code using volatile
  </title>
  <meta content="text/html; charset=utf-8" http-equiv="content-type"/>
  <link href="http://blog.regehr.org/wp-content/themes/barthelme/style.css" media="screen,projection" rel="stylesheet" title="Barthelme" type="text/css"/>
  <link href="http://blog.regehr.org/wp-content/themes/barthelme/print.css" media="print" rel="stylesheet" type="text/css"/>
  <link href="http://blog.regehr.org/feed" rel="alternate" title="Embedded in Academia RSS feed" type="application/rss+xml"/>
  <link href="http://blog.regehr.org/comments/feed" rel="alternate" title="Embedded in Academia comments RSS feed" type="application/rss+xml"/>
  <link href="http://blog.regehr.org/xmlrpc.php" rel="pingback"/>
  <link href="http://blog.regehr.org/archives/28/feed" rel="alternate" title="Embedded in Academia  Nine ways to break your systems code using volatile Comments Feed" type="application/rss+xml"/>
  <script type="text/javascript">
   window._wpemojiSettings = {"baseUrl":"http:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/blog.regehr.org\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.2.2"}};
			!function(a,b,c){function d(a){var c=b.createElement("canvas"),d=c.getContext&amp;&amp;c.getContext("2d");return d&amp;&amp;d.fillText?(d.textBaseline="top",d.font="600 32px Arial","flag"===a?(d.fillText(String.fromCharCode(55356,56812,55356,56807),0,0),c.toDataURL().length&gt;3e3):(d.fillText(String.fromCharCode(55357,56835),0,0),0!==d.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&amp;&amp;c.supports.flag||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&amp;&amp;c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&amp;&amp;f.twemoji&amp;&amp;(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
  </script>
  <style type="text/css">
   img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
  </style>
  <link href="http://blog.regehr.org/wp-content/plugins/mtouch-quiz/mtq_core_style.css?ver=3.1.2" id="mtq_CoreStyleSheets-css" media="all" rel="stylesheet" type="text/css"/>
  <link href="http://blog.regehr.org/wp-content/plugins/mtouch-quiz/mtq_theme_style.css?ver=3.1.2" id="mtq_ThemeStyleSheets-css" media="all" rel="stylesheet" type="text/css"/>
  <script src="http://blog.regehr.org/wp-includes/js/jquery/jquery.js?ver=1.11.2" type="text/javascript">
  </script>
  <script src="http://blog.regehr.org/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1" type="text/javascript">
  </script>
  <script src="http://blog.regehr.org/wp-content/plugins/mtouch-quiz/script.js?ver=3.1.2" type="text/javascript">
  </script>
  <script src="http://blog.regehr.org/wp-content/plugins/fd-footnotes/fdfootnotes.js?ver=1.3" type="text/javascript">
  </script>
  <link href="http://blog.regehr.org/xmlrpc.php?rsd" rel="EditURI" title="RSD" type="application/rsd+xml"/>
  <link href="http://blog.regehr.org/wp-includes/wlwmanifest.xml" rel="wlwmanifest" type="application/wlwmanifest+xml"/>
  <link href="http://blog.regehr.org/archives/26" rel="prev" title="Is That a Compiler Bug?"/>
  <link href="http://blog.regehr.org/archives/30" rel="next" title="50 Vertical Miles"/>
  <link href="http://blog.regehr.org/archives/28" rel="canonical"/>
  <link href="http://wp.me/pOk4P-s" rel="shortlink"/>
  <!-- &lt;meta name="NextGEN" version="2.1.0" /&gt; -->
  <style media="screen,projection" type="text/css">
   /*&lt;![CDATA[*/
/* CSS inserted by Barthelme theme options */
	body{font-family:arial,helvetica,sans-serif;font-size:90%;}
	div#content h2,div#content h3,div#content h4,div#content h5,div#content h6,body.archive div.archive-meta,body.attachment div.entry-content div.attachment-content p.attachment-name,body.home div#content div.entry-meta span,body.archive div#content div.entry-meta span,body.search div#content div.entry-meta span,body.single div.entry-date,body.single div.entry-meta,div#content blockquote,div.comments ol.commentlist li div.comment-meta,div.entry-content div.page-link,div.entry-content span.tag-links,body.page div.archive-meta,div.formcontainer form#commentform div.form-input input,div.formcontainer form#commentform div.form-textarea textarea#comment,input#s,div.entry-content div.entry-caption{font-family:georgia,times,serif;}
	body div#content div.hentry{text-align:left;}
	body div#wrapper{width:auto;}
	div#header,div#header h1#blog-title a,div#header h1#blog-title a:link,div#header h1#blog-title a:visited{color:#fefefe;outline:none;text-decoration:none;}
	body div#header{background:#bbc8d9 url("http://blog.regehr.org/wp-content/themes/barthelme/images/header-img.php?upper=8999b0&amp;lower=bbc8d9") repeat-x left top;}
/*]]&gt;*/
  </style>
  <style id="syntaxhighlighteranchor" type="text/css">
  </style>
 </head>
 <body class="wordpress y2015 m07 d14 h02 single s-y2010 s-m02 s-d26 s-h02 s-category-cs s-category-embedded s-category-software-correctness s-author-admin_dfs9gd0fg94h4">
  <div id="wrapper">
   <div id="header" onclick="location.href='http://blog.regehr.org/';">
    <h1 id="blog-title">
     <a href="http://blog.regehr.org/" title="Embedded in Academia">
      Embedded in Academia
     </a>
    </h1>
    <div id="blog-description">
    </div>
   </div>
   <!-- #header -->
   <div class="access">
    <span class="content-access">
     <a href="#content" title="Skip to content">
      Skip to content
     </a>
    </span>
   </div>
   <div id="globalnav">
    <ul id="menu">
     <li class="page_item_home home-link">
      <a href="http://blog.regehr.org/" rel="home" title="Embedded in Academia">
       Home
      </a>
     </li>
    </ul>
   </div>
   <div id="container">
    <div class="hfeed" id="content">
     <div class="hentry p1 post publish author-admin_dfs9gd0fg94h4 category-cs category-embedded category-software-correctness y2010 m02 d26 h02" id="post-28">
      <div class="entry-date">
       <span class="meta-sep">
        {
       </span>
       <abbr class="published" title="2010-02-26T20:49:00-0600">
        2010 02 26
       </abbr>
       <span class="meta-sep">
        }
       </span>
      </div>
      <h2 class="entry-title">
       Nine ways to break your systems code using volatile
      </h2>
      <div class="entry-content">
       <p>
        The volatile qualifier in C/C++ is a little bit like the C preprocessor: an ugly, blunt tool that is easy to misuse but that  in a very narrow set of circumstances  gets the job done. This article will first briefly explain volatile and its history and then, through a series of examples about how not to use it, explain how to most effectively create correct systems software using volatile. Although this article focuses on C, almost everything in it also applies to C++.
       </p>
       <h1>
        What does a C program mean?
       </h1>
       <p>
        The
        <a href="http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf">
         C standard
        </a>
        defines the meaning of a C program in terms of an abstract machine that you can think of as a simple, non-optimizing interpreter for C. The behavior of any given C implementation (a compiler plus target machine) must produce the same side effects as the abstract machine, but otherwise the standard mandates very little correspondence between the abstract machine and computation that actually happens on the target platform. In other words, the C program can be thought of as a specification of desired effects, and the C implementation decides how to best go about making those effects happen.
       </p>
       <p>
        As a simple example, consider this function:
       </p>
       <pre>
        <strong>
         int loop_add3 (int x) {
  int i;
  for (i=0; i&lt;3; i++) x++;
  return x;
}
        </strong>
       </pre>
       <p>
        The behavior of the abstract machine is clear: it creates a function-scoped variable named i which loops from 0 through 2, adding 1 to x on each iteration of the loop. On the other hand, a good compiler emits code like this:
       </p>
       <pre>
        <strong>
         loop_add3:
  movl 4(%esp), %eax
  addl $3, %eax
  ret
        </strong>
       </pre>
       <p>
        In the actual machine, i is never incremented or even instantiated, but the net effect is the same as if it had been. In general, this gap between the abstract and actual semantics is considered to be a good thing, and the as if wording in the standard is what gives the optimizer the freedom to generate efficient code from a high-level specification.
       </p>
       <h1>
        What does volatile mean?
       </h1>
       <p>
        The problem with the gap between the abstract and concrete semantics is that C is a low-level language that was designed for implementing operating systems. Writing OS code often requires that the gap between the abstract and actual semantics be narrowed or closed. For example, if an OS wants to create a new page table, the abstract semantics for C fails to capture an important fact: that the programmer requires an actual page table that sits in RAM where it can be traversed by hardware. If the C implementation concludes that the page table is useless and optimizes it away, the developers intent has not been served. The canonical example of this problem is when a compiler decides that a developers code for zeroing sensitive data is useless and optimizes it away. Since the C abstract machine was not designed to consider cases where this data may be snooped later, the optimization is legitimate (though obviously undesirable).
       </p>
       <p>
        The C standard gives us just a few ways to establish a connection between the abstract and actual machines:
       </p>
       <ul>
        <li>
         the arguments to main()
        </li>
        <li>
         the return value from main()
        </li>
        <li>
         the side-effecting functions in the C standard library
        </li>
        <li>
         volatile variables
        </li>
       </ul>
       <p>
        Most C implementations offer additional mechanisms, such as inline assembly and extra library functions not mandated by the standard.
       </p>
       <p>
        The way the volatile connects the abstract and real semantics is this:
       </p>
       <blockquote>
        <p>
         For every read from a volatile variable by the abstract machine, the actual machine must load from the memory address corresponding to that variable. Also, each read may return a different value. For every write to a volatile variable by the abstract machine, the actual machine must store to the corresponding address. Otherwise, the address should not be accessed (with some exceptions) and also accesses to volatiles should not be reordered (with some exceptions).
        </p>
       </blockquote>
       <p>
        In summary:
       </p>
       <ul>
        <li>
         Volatile has no effect on the abstract machine; in fact, the C standard explicitly states that for a C implementation that closely mirrors the abstract machine (i.e. a simple C interpreter), volatile has no effect at all.
        </li>
        <li>
         Accesses to volatile-qualified objects obligate the C implementation to perform certain operations at the level of the actual computation.
        </li>
       </ul>
       <h1>
        Where did volatile come from?
       </h1>
       <p>
        Historically, the connection between the abstract and actual machines was established mainly through accident: compilers werent good enough at optimizing to create an important semantic gap. As optimizers improved, it became increasingly clear that a systematic solution was needed. In an
        <a href="http://groups.google.com/group/comp.std.c/msg/7709e4162620f2cd">
         excellent USENET post
        </a>
        20 years ago Doug Gwyn explained how volatile came about:
       </p>
       <blockquote>
        <p>
         To take a specific example, UNIX device drivers are almost always coded entirely in C, and on the PDP-11 and similar memory-mapped I/O architectures, some device registers perform different actions upon a read-byte, read-word, write-byte, write-word, read-modify-write, or other variations of the memory-bus access cycles involved. Trying to get the right type of machine code generated while coding the driver in C was quite tricky, and many hard-to-track-down bugs resulted. With compilers other than Ritchies, enabling optimization often would change this behavior, too. At least one version of the UNIX Portable C Compiler (PCC) had a special hack to recognize constructs like
        </p>
        <pre>
         <strong>
          ((struct xxx *)0177450)-&gt;zzz
         </strong>
        </pre>
        <p>
         as being potential references to I/O space (device registers) and would avoid excessive optimization involving such expressions (where the constant lay within the Unibus I/O address range). X3J11 decided that this problem had to be faced squarely, and introduced volatile to obviate the need for such hacks. However, although it was proposed that conforming implementations be required to implement the minimum possible access width for volatile-qualified data, and that is the intent of requiring an implementation definition for it, it was not practical to insist on it in every implementation; thus, some latitude was allowed implementors in that regard.
        </p>
       </blockquote>
       <p>
        Its hard to overstate how bad an idea it is for a compiler to use strange heuristics about code structure to guess the developers intent.
       </p>
       <h1>
        Nine ways to break your systems code using volatile
       </h1>
       <h2>
        1. Not enough volatile
       </h2>
       <p>
        The most obvious kind of volatile error is to leave it out when it is required. Lets look at a specific example. Suppose were developing software for an AVR 8-bit embedded processor, which (on some models) has no hardware multiplier. Since multiplies are going to happen in software, were probably interested in seeing how slow they are, so we know how hard to try to avoid them. So we write a little benchmark program like this:
       </p>
       <pre>
        <strong>
         #define TCNT1 (*(uint16_t *)(0x4C))
        </strong>
       </pre>
       <pre>
        <strong>
         signed char a, b, c;
        </strong>
       </pre>
       <pre>
        <strong>
         uint16_t time_mul (void) {
  uint16_t first = TCNT1;
  c = a * b;
  uint16_t second = TCNT1;
  return second - first;
}
        </strong>
       </pre>
       <p>
        Here TCNT1 points to a hardware register living at address 0x4C. This register provides access to Timer/Counter 1: a free-running 16-bit timer that we assume is configured to run at some rate appropriate for this experiment. We read the register before and after the multiply operation, and subtract to find the duration. Side note: although at first glance this code looks like it fails to account for the case where TCNT1 overflows from 65535 to 0 during the timing run, it actually works properly for all durations between 0 and 65535 ticks.
       </p>
       <p>
        Unfortunately, when we run this code, it always reports that the multiply operation required zero clock ticks. To see what went wrong, let us look at the assembly language:
       </p>
       <pre>
        <strong>
         $ avr-gcc -Os -S -o - reg1.c
time_mul:
  lds r22,a
  lds r24,b
  rcall __mulqi3
  sts c,r24
  ldi r24,lo8(0)
  ldi r25,hi8(0)
  ret
        </strong>
       </pre>
       <p>
        Now the problem is obvious: both reads from the TCNT1 register have been eliminated and the function is simply returning the constant zero (avr-gcc returns a 16-bit value in the r24:r25 register pair).
       </p>
       <p>
        How can the compiler get away with never reading from TCNT1? First, lets remember that the meaning of a C program is defined by the abstract machine described in the C standard. Since the rules for the abstract machine say nothing about hardware registers (or concurrent execution) the C implementation is permitted to assume that two reads from an object, with no intervening stores, both return the same value. Of course, any value subtracted from itself is zero. So the translation performed by avr-gcc here is perfectly correct; it is our program thats wrong.
       </p>
       <p>
        To fix the problem, we need to change the code so that TCNT1 points to a volatile location.
       </p>
       <pre>
        <strong>
         #define TCNT1 (*(volatile uint16_t *)(0x4C))
        </strong>
       </pre>
       <p>
        Now, the C implementation is not free to eliminate the reads and also it cannot assume the same value is read both times. This time the compiler outputs better code:
       </p>
       <pre>
        <strong>
         $ avr-gcc -Os -S -o - reg2.c
time_mul:
  in r18,0x2c
  in r19,0x2d
  lds r22,a
  lds r24,b
  rcall __mulqi3
  sts c,r24
  in r24,0x2c
  in r25,0x2d
  sub r24,r18
  sbc r25,r19
  ret
        </strong>
       </pre>
       <p>
        Although this assembly code is correct, our C code still contains a latent error. Well explore it later.
       </p>
       <p>
        Normally, you will find definitions for device registers in system header files. If so, you will not need to use volatile in this case. But it may be worth checking that the definitions are correct, they arent always.
       </p>
       <p>
        Lets look at another example. In an embedded system you are implementing, some computation must wait for an interrupt handler to fire. Your code looks like this:
       </p>
       <pre>
        <strong>
         int done;
        </strong>
       </pre>
       <pre>
        <strong>
         __attribute((signal)) void __vector_4 (void) {
  done = 1;
}
        </strong>
       </pre>
       <pre>
        <strong>
         void wait_for_done (void) {
  while (!done) ;
}
        </strong>
       </pre>
       <p>
        Here wait_for_done() is designed to be called from the non-interrupt context, whereas __vector_4() will be invoked by the interrupt controller in response to some external event. We compile this code into assembly:
       </p>
       <pre>
        <strong>
         $ avr-gcc -Os wait.c -S -o -
__vector_4:
  push r0
  in r0,__SREG__
  push r0
  push r24
  ldi r24,lo8(1)
  sts done,r24
  pop r24
  pop r0
  out __SREG__,r0
  pop r0
  reti
        </strong>
       </pre>
       <pre>
        <strong>
         wait_for_done:
  lds r24,done
.L3:
  tst r24
  breq .L3
  ret
        </strong>
       </pre>
       <p>
        The code for the interrupt handler looks good: it stores to done as intended. The rest of the interrupt handler is just AVR interrupt boilerplate. However, the code for wait_for_done() contains an important flaw: it is spinning on r24 instead of spinning on a RAM location. This happens because the C abstract machine has no notion of communication between concurrent flows (whether they are threads, interrupts, or anything else). Again, the translation is perfectly correct, but does not match the developers intent.
       </p>
       <p>
        If we mark done as a volatile variable, the interrupt handler code does not change, but wait_for_done() now looks like this:
       </p>
       <pre>
        <strong>
         wait_for_done:
.L3:
  lds r24,done
  tst r24
  breq .L3
  ret
        </strong>
       </pre>
       <p>
        This code will work. The issue here is one of visibility. When you store to a global variable in C, what computations running on the machine are guaranteed to see the store? When you load from a global variable, what computations are assumed to have produced the value? In both cases, the answer is the computation that performs the load or store is assumed to be the only computation that matters. That is, C makes no visibility guarantees for normal variable references. The volatile qualifier forces stores to go to memory and loads to come from memory, giving us a way to ensure visibility across multiple computations (threads, interrupts, coroutines, or whatever).
       </p>
       <p>
        Again, our C code contains a latent bug that well investigate later.
       </p>
       <p>
        A few other legitimate uses of volatile, including making variables in UNIX programs visible to signal handlers, are
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html">
         discussed by Hans Boehm
        </a>
        .
       </p>
       <p>
        <strong>
         Summary: The abstract C machine is connected to the actual machine in only a few places. The memory behavior of the actual machine may be very different from the operations specified in source code. If you require additional connections between the two levels of abstraction, for example to access device registers, the volatile qualifier can help.
        </strong>
       </p>
       <h2>
        2. Too much volatile
       </h2>
       <p>
        In a well-designed piece of software, volatile is used exactly where it is needed. It serves as documentation, saying in effect this variable does not play by the C rules: it requires a strong connection with the memory subsystem. In a system that uses too much volatile, variables will be indiscriminately labeled as volatile, without any technical justification. There are three reasons why this is bad. First, its bad documentation and will confuse subsequent maintainers. Second, volatile sometimes has the effect of hiding program bugs such as race conditions. If your code needs volatile and you dont understand why, this is probably what is happening. Far better to actually fix the problem than to rely on a hack you do not understand to solve a problem you do not understand. Finally, volatile causes inefficiency by handicapping the optimizer. The overhead that it introduces is hard to track down since it is spread out all over the system a profiler will be little help in finding it.
       </p>
       <p>
        Using volatile is a little like deciding what kind of insurance policy to buy. Too little insurance and you may run into problems down the road. Too much insurance and youre covered but in the long run you end up paying too much.
       </p>
       <p>
        <strong>
         Summary: Use volatile only when you can provide a precise technical justification. Volatile is not a substitute for thought (
         <a href="http://www.netrino.com/Embedded-Systems/How-To/C-Volatile-Keyword">
          Nigel Jones said this
         </a>
         ).
         <br/>
        </strong>
       </p>
       <h2>
        3. Misplaced qualification
       </h2>
       <p>
        At the level of C syntax, volatile is a type qualifier. It can be applied to any type, following rules that are similar to, but not quite the same as, the rules for the const qualifier. The situation can become confusing when qualified types are used to build up more complex types. For example, there are four possible ways to qualify a single-level pointer:
       </p>
       <pre>
        <strong>
         int *p;                              // pointer to int
volatile int *p_to_vol;              // pointer to volatile int
int *volatile vol_p;                 // volatile pointer to int
volatile int *volatile vol_p_to_vol; // volatile pointer to volatile int
        </strong>
       </pre>
       <p>
        In each case, either the pointer is volatile or not, and the pointer target is volatile or not. The distinction is crucial: if you use a volatile pointer to regular int to access a device register, the compiler is free to optimize away accesses to the register. Also, you will get slow code since the compiler will not be free to optimize accesses to the pointer. This problem comes up pretty often on embedded mailing lists; its an easy mistake to make. Its also easy to overlook when vetting code since your eye may just be looking for a volatile somewhere.
       </p>
       <p>
        For example, this code is wrong:
       </p>
       <pre>
        <strong>
         int *volatile REGISTER = 0xfeed;
*REGISTER = new_val;
        </strong>
       </pre>
       <p>
        To write clear, maintainable code using volatile, a reasonable idea is to build up more complex types using typedefs (of course this is a good idea anyway). For example we could first make a new type vint which is a volatile int:
       </p>
       <pre>
        <strong>
         typedef volatile int vint;
        </strong>
       </pre>
       <p>
        Next, we create a pointer-to-vint:
       </p>
       <pre>
        <strong>
         vint *REGISTER = 0xfeed;
        </strong>
       </pre>
       <p>
        Members of a struct or union can be volatile, and structs/unions can also be volatile. If an aggregate type is volatile, the effect is the same as making all members volatile.
       </p>
       <p>
        We might ask, does it make sense to declare an object as both const and volatile?
       </p>
       <pre>
        <strong>
         const volatile int *p;
        </strong>
       </pre>
       <p>
        Although this initially looks like a contradiction, it is not. The semantics of const in C are I agree not to try to store to it rather than it does not change. So in fact this qualification is perfectly meaningful and would even be useful, for example, to declare a timer register than spontaneously changes value, but that should not be stored to (this example is specifically pointed out in the C standard).
       </p>
       <p>
        <strong>
         Summary: Since Cs type declaration syntax is not particularly readable or intuitive, volatile qualifiers must be placed with care. Typedefs are a useful way to structure complex declarations.
        </strong>
       </p>
       <h2>
        4. Inconsistent qualification
       </h2>
       <p>
        The last version of Linux 2.2 was 2.2.26. In that version, in the file arch/i386/kernel/smp.c at line 125, we find this definition:
       </p>
       <pre>
        <strong>
         volatile unsigned long ipi_count;
        </strong>
       </pre>
       <p>
        So far, no problem: were declaring a long to store the number of inter-processor interrupts and making it volatile. However, in the header file include/asm-i386/smp.h at line 178 we find this definition:
       </p>
       <pre>
        <strong>
         extern unsigned long ipi_count;
        </strong>
       </pre>
       <p>
        C files that include this header will not treat ipi_count as volatile, and this could easily cause problems. Kernels in the 2.3 series also contain this error.
       </p>
       <p>
        Recent versions of gcc treat this kind of inconsistent qualification as a compile-time error, so these problems have disappeared. However, its a good bet that some embedded compilers (obviously including those based on older versions of gcc) will permit you to make this mistake.
       </p>
       <p>
        Another way to get inconsistent qualification is through typecasts. Casts can be implicit, for example passing a pointer-to-volatile to a function expecting an unqualified pointer. The compiler will warn about this; these warnings should never be ignored or suppressed. Explicit typecasts that remove qualifiers should be avoided, these generally do not cause any warnings. The C standard explicitly states that a programs behavior is undefined if you access a volatile object through an unqualified pointer.
       </p>
       <p>
        <strong>
         Summary: Never use inconsistent qualification. If a variable is declared as volatile, then all accesses to it, direct or indirect, must be through volatiles and pointers-to-volatile.
         <br/>
        </strong>
       </p>
       <h2>
        5. Expecting volatile to enforce ordering with non-volatile accesses
       </h2>
       <p>
        Next we come to an issue that even some experts in embedded software development get wrong, and that even experts in C language semantics have arguments about.
       </p>
       <p>
        The question is: What was wrong with the fixed C code examples above, where we added volatile to the TCNT1 register handle and to the done flag? The answer, depending on who you believe, is either nothing or else the compiler may reorder the operations in such a way as to create broken output.
       </p>
       <p>
        One school of thought is that compilers may not move accesses to global variables around accesses to volatile variables. There seems to be a consistent reading of the standard that backs this up. The problem with this reading is that important compilers are based on a different interpretation, which says that accesses to non-volatile objects can be arbitrarily moved around volatile accesses.
       </p>
       <p>
        Take this simple example (which originated with Arch Robison):
       </p>
       <pre>
        <strong>
         volatile int ready;
int message[100];
        </strong>
       </pre>
       <pre>
        <strong>
         void foo (int i) {
  message[i/10] = 42;
  ready = 1;
}
        </strong>
       </pre>
       <p>
        The purpose of foo() is to store a value into the message array and then set the ready flag so that another interrupt or thread can see the value. From this code, GCC, Intel CC, Sun CC, and Open64 emit very similar assembly:
       </p>
       <pre>
        <strong>
         $ gcc -O2 barrier1.c -S -o -
foo:
  movl 4(%esp), %ecx
  movl $1717986919, %edx
  movl $1, ready
  movl %ecx, %eax
  imull %edx
  sarl $31, %ecx
  sarl $2, %edx
  subl %ecx, %edx
  movl $42, message(,%edx,4)
  ret
        </strong>
       </pre>
       <p>
        Obviously the programmers intent is not respected here, since the flag is stored prior to the value being written into the array. As of this writing LLVM does not do this reordering but, as far as I know, this is a matter of chance rather than design. A number of embedded compilers refuse to do this kind of reordering as a deliberate choice to prefer safety over performance. Ive heard, but not checked, that recent Microsoft C/C++ compilers also take a very conservative stance on volatile accesses. This is probably the right choice, but it doesnt help people who have to write portable code.
       </p>
       <p>
        One way to fix this problem is to declare message as a volatile array. The C standard is unambiguous that volatile side effects must not move past sequence points, so this will work. On the other hand, adding more volatile qualifiers may suppress interesting optimizations elsewhere in the program. Wouldnt it be nice if we could force data to memory only at selected program points without making things volatile everywhere?
       </p>
       <p>
        The construct that we need is a compiler barrier. The C standard does not provide this, but many compilers do. For example, GCC and sufficiently compatible compilers (including LLVM and Intel CC) support a memory barrier that looks like this:
       </p>
       <pre>
        <strong>
         asm volatile ("" : : : "memory");
        </strong>
       </pre>
       <p>
        It means roughly this inline assembly code, although it contains no instructions, may read or write all of RAM. The effect is that the compiler dumps all registers to RAM before the barrier and reloads them afterwards. Moreover, code motion is not permitted around the barrier in either direction. Basically a compiler barrier is to an optimizing compiler as a memory barrier is to an out-of-order processor.
       </p>
       <p>
        We can use a barrier in the code example:
       </p>
       <pre>
        <strong>
         volatile int ready;
int message[100];
        </strong>
       </pre>
       <pre>
        <strong>
         void foo (int i) {
  message[i/10] = 42;
  asm volatile ("" : : : "memory");
  ready = 1;
}
        </strong>
       </pre>
       <p>
        Now the output is what we wanted:
       </p>
       <pre>
        <strong>
         $ gcc -O2 barrier2.c -S -o -
foo:
  movl 4(%esp), %ecx
  movl $1717986919, %edx
  movl %ecx, %eax
  imull %edx
  sarl $31, %ecx
  sarl $2, %edx
  subl %ecx, %edx
  movl $42, message(,%edx,4)
  movl $1, ready
  ret
        </strong>
       </pre>
       <p>
        What about compilers that fail to support memory barriers? One bad solution is to hope that this kind of compiler isnt aggressive enough to move accesses around in a harmful way. Another bad solution is to insert a call to an external function where you would put the barrier. Since the compiler doesnt know what memory will be touched by this function, it may have a barrier-like effect. A better solution would be to ask your compiler vendor to fix the problem and also to recommend a workaround in the meantime.
       </p>
       <p>
        <strong>
         Summary: Most compilers can and will move accesses to non-volatile objects around accesses to volatile objects, so dont rely on the program ordering being respected.
        </strong>
       </p>
       <h2>
        6. Using volatile to get atomicity
       </h2>
       <p>
        Earlier we saw a case where volatile was used to make a value visible to a concurrently running computation. This was  in limited circumstances  a valid implementation choice. On the other hand it is never valid to use volatile to get atomicity.
       </p>
       <p>
        Somewhat surprisingly for a systems programming language, C does not provide guarantees about atomicity of its memory operations, regardless of the volatility of objects being accessed. Generally, however, individual compilers will make guarantees such as aligned accesses to word-sized variables are atomic.
       </p>
       <p>
        In most cases, you use locks to get atomicity. If youre lucky, you have access to well-designed locks that contain compiler barriers. If youre programming on bare metal on an embedded processor, you may not be so lucky. If you have to devise your own locks, it would be wise to add compiler barriers. For example, older versions of
        <a href="http://tinyos.net/">
         TinyOS
        </a>
        for AVR chips used these functions to acquire and release the global interrupt lock:
       </p>
       <pre>
        <strong>
         char __nesc_atomic_start (void) {
  char result = SREG;
  __nesc_disable_interrupt();
  return result;
}
        </strong>
       </pre>
       <pre>
        <strong>
         void __nesc_atomic_end (char save) {
  SREG = save;
}
        </strong>
       </pre>
       <p>
        Since these functions can be (and generally are) inlined, it was always possible for the compiler to move code outside of a critical section. We changed the locks to look like this:
       </p>
       <pre>
        <strong>
         char__nesc_atomic_start(void) {
  char result = SREG;
  __nesc_disable_interrupt();
  asm volatile("" : : : "memory");
  return result;
}
        </strong>
       </pre>
       <pre>
        <strong>
         void __nesc_atomic_end(char save) {
  asm volatile("" : : : "memory");
  SREG = save;
}
        </strong>
       </pre>
       <p>
        Perhaps interestingly, this had no effect on TinyOS efficiency and even made the code smaller in some cases.
       </p>
       <p>
        <strong>
         Summary: Volatile has nothing to do with atomicity. Use locks.
        </strong>
       </p>
       <h2>
        7. Using volatile on a modern machine
       </h2>
       <p>
        Volatile is of very limited usefulness on a machine that is out-of-order, multiprocessor, or both. The problem is that while volatile forces the compiler to emit memory operations on the actual machine, these loads and stores by themselves do not constrain the hardwares behavior very much. It is vastly preferable to find good locking primitives and use them, as opposed to rolling them yourself. Consider this spin-unlock function from the ARM port of Linux:
       </p>
       <pre>
        <strong>
         static inline void arch_spin_unlock(arch_spinlock_t *lock) {
  smp_mb();
  __asm__ __volatile__("str %1, [%0]\n" : : "r" (&amp;lock-&gt;lock), "r" (0) : "cc");
}
        </strong>
       </pre>
       <p>
        Before unlocking, smp_mb() is executed, which boils down to something like this:
       </p>
       <pre>
        <strong>
         __asm__ __volatile__ ("dmb" : : : "memory");
        </strong>
       </pre>
       <p>
        This is both a compiler barrier and a memory barrier.
       </p>
       <p>
        <strong>
         Summary: Without help from properly designed synchronization libraries, writing correct concurrent code on an out-of-order machine or multiprocessor is extremely hard, and volatile is of little help.
        </strong>
       </p>
       <h2>
        8. Using volatile in multi-threaded code
       </h2>
       <p>
        This issue overlaps with the previous two but its important enough to be worth repeating. Arch Robison says that
        <a href="http://software.intel.com/en-us/blogs/2007/11/30/volatile-almost-useless-for-multi-threaded-programming/">
         volatile is almost useless for multi-threaded programming
        </a>
        . And hes right. If you have threads then you should also have locks, and should use them. Theres a wonderful result showing that properly synchronized code  where shared variables are always accessed from within critical sections  executes in a sequentially consistent fashion (provided that the locks are properly implemented, and you shouldnt have to worry about that). This means that if you use locks, you dont have to worry about compiler barriers, memory system barriers, or volatile. None of it matters.
       </p>
       <p>
        <strong>
         Summary: To write correct multi-threaded code, you need primitives providing (at least) atomicity and visibility. On modern hardware volatile provides neither. You should write properly synchronized multi-threaded code whenever possible. Idioms like double-checked locking are best avoided.
        </strong>
       </p>
       <h2>
        9. Assume volatile accesses are translated correctly
       </h2>
       <p>
        Compilers are not totally reliable in their translation of accesses to volatile-qualified objects. Ive
        <a href="http://www.cs.utah.edu/~regehr/papers/emsoft08-preprint.pdf">
         written extensively about this subject elsewhere
        </a>
        , but heres a quick example:
       </p>
       <pre>
        <strong>
         volatile int x;
        </strong>
       </pre>
       <pre>
        <strong>
         void foo (void) {
  x = x;
}
        </strong>
       </pre>
       <p>
        The proper behavior of this code on the actual machine is unambiguous: there should be a load from x, then a store to it. However, the port of GCC to the MSP430 processor behaves differently:
       </p>
       <pre>
        <strong>
         $ msp430-gcc -O vol.c -S -o -
foo:
  ret
        </strong>
       </pre>
       <p>
        The emitted function is a nop. It is wrong. In general, compilers based on gcc 4.x are mostly volatile-correct, as are recent versions of LLVM and Intel CC. Pre-4.0 versions of gcc have problems, as do a number of other compilers.
       </p>
       <p>
        <strong>
         Summary: If your code makes correct use of volatiles and still does not work, consider reading the compilers output to make sure it has emitted the proper memory operations.
        </strong>
       </p>
       <h1>
        What about the Linux people?
       </h1>
       <p>
        You can find various rants, screeds, and diatribes against volatile on Linux mailing lists and web pages. These are largely correct, but you have to keep in mind that:
       </p>
       <ol>
        <li>
         Linux often runs on out-of-order multicores where volatile by itself is nearly useless.
        </li>
        <li>
         The Linux kernel provides a rich collection of functions for synchronization and hardware access that, properly used, eliminate almost all need for volatile in regular kernel code.
        </li>
       </ol>
       <p>
        If you are writing code for an in-order embedded processor and have little or no infrastructure besides the C compiler, you may need to lean more heavily on volatile.
       </p>
       <h1>
        Summary
       </h1>
       <p>
        Optimizing compilers are tricky to reason about, as are out-of-order processors. Also, the C standard contains some very dark corners. The volatile qualifier invites all of these difficulties to come together in one place and interact with one another. Furthermore, it provides weaker guarantees than people commonly assume. Careful thought is required to create correct software using volatile.
       </p>
       <p>
        Happily, most programmers who write user-mode C and C++ can get away without ever using volatile. Also, the vast majority of kernel mode programmers will seldom if ever need volatile. It is primarily needed by people working near bare metal; for example, working on an embedded microcontroller or porting an OS to a new platform.
       </p>
       <h1>
        Credentials
       </h1>
       <p>
        Ive been programming computers for 26 years and embedded systems for 17 years. For the last eight years Ive taught operating systems, embedded systems, compilers, and related courses to undergrads and graduate students. Ive tried to educate them about volatile and have a pretty good idea about where people go wrong with it.
       </p>
       <p>
        In February 2010 I gave some lectures at RWTH Aachen, including about an hour on getting the volatile qualifier wrong. This post expands on that material.
       </p>
      </div>
      <div class="entry-meta">
       <span class="entry-published">
        Posted by
        <span class="entry-author author vcard">
         <span class="fn n">
          regehr
         </span>
        </span>
        on
        <abbr class="published" title="2010-02-26T20:49:00-0600">
         Friday, February 26, 2010, at 8:49 pm
        </abbr>
        .
       </span>
       <span class="cat-links">
        Filed under
        <a href="http://blog.regehr.org/archives/category/cs" rel="category tag">
         Computer Science
        </a>
        ,
        <a href="http://blog.regehr.org/archives/category/embedded" rel="category tag">
         Embedded
        </a>
        ,
        <a href="http://blog.regehr.org/archives/category/software-correctness" rel="category tag">
         Software Correctness
        </a>
        .
       </span>
       <span class="entry-rsslink">
        Follow any responses to this post with its
        <a href="http://blog.regehr.org/archives/28/feed" rel="alternate" title="Comments RSS to Nine ways to break your systems code using volatile" type="application/rss+xml">
         comments RSS
        </a>
        feed.
       </span>
       <span class="entry-interact">
        Both comments and trackbacks are currently closed.
       </span>
      </div>
     </div>
     <!-- .post -->
     <div class="comments">
      <h3 class="comment-header" id="numcomments">
       <span class="comment-count">
        <span class="meta-sep">
         {
        </span>
        9
        <span class="meta-sep">
         }
        </span>
       </span>
       Comments
      </h3>
      <ol class="commentlist" id="comments">
       <li class="comment c-y2010 c-m04 c-d12 c-h08 alt c1" id="comment-217">
        <div class="comment-meta">
         <span class="comment-author vcard">
          <span class="fn n">
           Bruce Wedding
          </span>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-datetime">
          <abbr class="comment-published" title="2010-02-26T20:49:00-0600">
           April 12, 2010 at 2:17 pm
          </abbr>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-permalink">
          <a href="#comment-217" title="Permalink to this comment">
           Permalink
          </a>
         </span>
        </div>
        <p>
         Regarding the example #5, I must be confused about the definition of a sequence point because the resulting assembly output seems to be non-ANSI C:
        </p>
        <p>
         void foo (int i) {
         <br/>
         message[i/10] = 42;
         <br/>
         ready = 1;
         <br/>
         }
        </p>
        <p>
         The full statement,   message[i/10] = 42; is a sequence point. My understanding is that the fact that it is a sequence point ensures that it will be performed prior to the next line of code. So how can 1 be moved into ready prior to 42 being assigned the the message[] array, as your assembly output shows?
        </p>
        <p>
         foo:
         <br/>
         movl $1, ready
         <br/>
         
         <br/>
         movl $42, message(,%edx,4)
         <br/>
         ret
        </p>
        <p>
         Your clarification is appreciated because it appears I dont fully understand the purpose or behavior of a sequence point. It seems to me, if the lines of code in a function can be evaluated in any order, nothing would run.
        </p>
        <p>
         Thanks,
         <br/>
         Bruce
        </p>
       </li>
       <li class="comment byuser commentauthor-admin_dfs9gd0fg94h4 bypostauthor c-y2010 c-m04 c-d12 c-h04 c2" id="comment-219">
        <div class="comment-meta">
         <span class="comment-author vcard">
          <span class="fn n">
           <a class="url url" href="http://www.cs.utah.edu/~regehr/" rel="external nofollow">
            regehr
           </a>
          </span>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-datetime">
          <abbr class="comment-published" title="2010-02-26T20:49:00-0600">
           April 12, 2010 at 10:56 pm
          </abbr>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-permalink">
          <a href="#comment-219" title="Permalink to this comment">
           Permalink
          </a>
         </span>
        </div>
        <p>
         Hi Bruce-  Im glad you asked about this!  Youve touched on a part of the standard that I think is pretty ambiguous, and that even experts argue about.
        </p>
        <p>
         First, of course you are correct that there is a sequence point following message[i/10]=42;
        </p>
        <p>
         Second, heres what the standard (Im looking at page 25 of N1124) says about sequence points:  At certain specified points in the execution sequence called sequence points, all side effects of previous evaluations shall be complete and no side effects of subsequent evaluations shall have taken place. 
        </p>
        <p>
         The question we now have to ask is: Is it a side effect to store to an element of message?
        </p>
        <p>
         Case 1:  Yes, it is a side effect.  The problem is that no optimizing C compiler takes this interpretation.  For example, a compiler that took this literally would have to emit two stores if you wrote this code: x=1; x=2;.  Of course, any good optimizing compiler will eliminate the first store as it cannot be observed.
        </p>
        <p>
         Case 2: The array store is not a side effect.  In this interpretation, accesses to volatile objects and calls to side-effecting functions (like printf) are side effects, but stores to globals are not.  If we take this view (all optimizing compilers I am aware of do) then the text I wrote in this post applies.
        </p>
        <p>
         Hope this is helpful!
        </p>
       </li>
       <li class="comment c-y2010 c-m04 c-d26 c-h03 alt c3" id="comment-251">
        <div class="comment-meta">
         <span class="comment-author vcard">
          <span class="fn n">
           ralf
          </span>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-datetime">
          <abbr class="comment-published" title="2010-02-26T20:49:00-0600">
           April 26, 2010 at 9:38 am
          </abbr>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-permalink">
          <a href="#comment-251" title="Permalink to this comment">
           Permalink
          </a>
         </span>
        </div>
        <p>
         Again, on point 5, I think those compilers are broken. Actually, Ive had this argument many times, and still havent heard a convincing argument (including yours above) that these compilers are correct.
        </p>
        <p>
         Taken with your own point The C standard is unambiguous that volatile side effects must not move past sequence points, so this will work the only valid interpretation of no side effects of subsequent evaluations shall have taken place  is that the volatile variable is not modified until after the sequence point between the two statements.
        </p>
       </li>
       <li class="comment byuser commentauthor-admin_dfs9gd0fg94h4 bypostauthor c-y2010 c-m04 c-d26 c-h04 c4" id="comment-252">
        <div class="comment-meta">
         <span class="comment-author vcard">
          <span class="fn n">
           <a class="url url" href="http://www.cs.utah.edu/~regehr/" rel="external nofollow">
            regehr
           </a>
          </span>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-datetime">
          <abbr class="comment-published" title="2010-02-26T20:49:00-0600">
           April 26, 2010 at 10:00 am
          </abbr>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-permalink">
          <a href="#comment-252" title="Permalink to this comment">
           Permalink
          </a>
         </span>
        </div>
        <p>
         Hi Ralf,
        </p>
        <p>
         Thanks for the comment.   I think if you look closely at the example used in point 5, youll see that the volatile access does not need to move past any sequence point.  Rather, the store-to-global is what moves.
        </p>
        <p>
         Anyway, it may well be that these compilers are broken.  However, unless the compiler vendors can be convinced of this (its probably worth trying, but in my experience they cannot), it still leaves embedded developers with the same problem of coping with tools that act like this, or else somehow making sure that their code will only be built using non-broken compilers.
        </p>
        <p>
         John
        </p>
       </li>
       <li class="comment c-y2010 c-m04 c-d26 c-h06 alt c5" id="comment-253">
        <div class="comment-meta">
         <span class="comment-author vcard">
          <span class="fn n">
           Ralf
          </span>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-datetime">
          <abbr class="comment-published" title="2010-02-26T20:49:00-0600">
           April 26, 2010 at 12:32 pm
          </abbr>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-permalink">
          <a href="#comment-253" title="Permalink to this comment">
           Permalink
          </a>
         </span>
        </div>
        <p>
         Hi John,
        </p>
        <p>
         I see what youre saying, but it essentially makes no difference. In this 2 line function, there is clearly a sequence point between the 2 instructions. Interpreting the spec such that the non-volatile access can move past a volatile access clearly invalidates it in all cases except 2 volatile accesses. In any case, if the volatile write is done before the array write, then the volatile instruction *has* moved past the sequence point before it.
        </p>
        <p>
         An example, in {a;b;c;volatile;d;e;f;}, its fine to rearrange {a;b;c;} and {d;e;f;} at will, e.g. to produce {c;b;a;volatile;f;d;e}, but it is not correct to rearrange any of these statements outside of their triplet because doing so necessarily causes the volatile to move across a sequence point.
        </p>
        <p>
         I guess it boils down, as you say, to whether a memory access is a side effect. Personally, Id argue that it is a side-effect (and in fact, this causes the compiler no problems as it can still re-order any non-volatile statements), but if the accepted view is that this is wrong, then I guess its something we have to live with.
        </p>
        <p>
         Certainly, I agree that compiler vendors are unlikely to change their implementations and that its best to highlight that this problem exists and work around it as you describe.
        </p>
        <p>
         Ralf
        </p>
       </li>
       <li class="comment byuser commentauthor-admin_dfs9gd0fg94h4 bypostauthor c-y2010 c-m04 c-d27 c-h03 c6" id="comment-254">
        <div class="comment-meta">
         <span class="comment-author vcard">
          <span class="fn n">
           <a class="url url" href="http://www.cs.utah.edu/~regehr/" rel="external nofollow">
            regehr
           </a>
          </span>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-datetime">
          <abbr class="comment-published" title="2010-02-26T20:49:00-0600">
           April 27, 2010 at 9:31 am
          </abbr>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-permalink">
          <a href="#comment-254" title="Permalink to this comment">
           Permalink
          </a>
         </span>
        </div>
        <p>
         Hi Ralf,
        </p>
        <p>
         I suspect we largely agree.  It probably sounds like Im trying to defend the standard and the implementations but my intent is just to come up with a pragmatic explanation of the situation that developers are likely to find themselves in.  It is definitely broken, but the breakage can often be worked around through prudent engineering.  Anyway, a new post is coming soon with even more fun issues ;).
        </p>
        <p>
         John
        </p>
       </li>
       <li class="comment c-y2010 c-m08 c-d04 c-h07 alt c7" id="comment-856">
        <div class="comment-meta">
         <span class="comment-author vcard">
          <span class="fn n">
           <a class="url url" href="http://www.utilize.co.uk/" rel="external nofollow">
            Essex IT Support
           </a>
          </span>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-datetime">
          <abbr class="comment-published" title="2010-02-26T20:49:00-0600">
           August 4, 2010 at 1:13 pm
          </abbr>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-permalink">
          <a href="#comment-856" title="Permalink to this comment">
           Permalink
          </a>
         </span>
        </div>
        <p>
         C is a good and much easier way of  programming. This really helps me understand more of C programming.
        </p>
        <p>
         Thanks for the information.
        </p>
       </li>
       <li class="comment c-y2011 c-m01 c-d23 c-h09 c8" id="comment-1814">
        <div class="comment-meta">
         <span class="comment-author vcard">
          <span class="fn n">
           Melbourne
          </span>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-datetime">
          <abbr class="comment-published" title="2010-02-26T20:49:00-0600">
           January 24, 2011 at 3:32 am
          </abbr>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-permalink">
          <a href="#comment-1814" title="Permalink to this comment">
           Permalink
          </a>
         </span>
        </div>
        <p>
         volatile is implementation-defined. As the C-standard says, What constitutes an access to an object that has volatile- qualified type is implementation-defined, so use of volatile boils down to whatever your compiler does on your platform.
         <br/>
         Having said that, the meaning of
        </p>
        <pre class="brush: plain; title: ; notranslate" title="">
         __asm__ __volatile__ ("dmb" : : : "memory");
        </pre>
        <p>
         is also implementation-defined, so the suggested solution (and the suggested class of solutions) is not really a solution to anything at all.
        </p>
       </li>
       <li class="comment byuser commentauthor-admin_dfs9gd0fg94h4 bypostauthor c-y2011 c-m01 c-d24 c-h08 alt c9" id="comment-1817">
        <div class="comment-meta">
         <span class="comment-author vcard">
          <span class="fn n">
           <a class="url url" href="http://www.cs.utah.edu/~regehr/" rel="external nofollow">
            regehr
           </a>
          </span>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-datetime">
          <abbr class="comment-published" title="2010-02-26T20:49:00-0600">
           January 24, 2011 at 2:34 pm
          </abbr>
         </span>
         <span class="meta-sep">
          |
         </span>
         <span class="comment-permalink">
          <a href="#comment-1817" title="Permalink to this comment">
           Permalink
          </a>
         </span>
        </div>
        <p>
         Hi Melbourne,
        </p>
        <p>
         The implementation-definedness is a little bit irrelevant since there is pretty solid agreement among compiler developers and compiler users that a volatile on the RHS of an expression means the volatile location should be loaded from, and a volatile on the LHS of an expression means the volatile location should be stored to.
        </p>
        <p>
         Basically, in spite of some ugly stuff in the standard, people want and need a usable language for systems work.
        </p>
       </li>
      </ol>
      <!-- end #comments .commentlist -->
     </div>
     <!-- .comments -->
     <div class="navigation" id="nav-below">
      <div class="nav-previous">
       
       <a href="http://blog.regehr.org/archives/26" rel="prev">
        Is That a Compiler Bug?
       </a>
      </div>
      <div class="nav-next">
       <a href="http://blog.regehr.org/archives/30" rel="next">
        50 Vertical Miles
       </a>
       
      </div>
     </div>
    </div>
    <!-- #content .hfeed -->
   </div>
   <!-- #container -->
   <div class="sidebar" id="primary">
    <ul>
     <li class="widget widget_text" id="text-3">
      <h3 class="widgettitle">
       About me
      </h3>
      <div class="textwidget">
       John Regehr
       <br/>
       Associate Professor of Computer Science
       <br/>
       University of Utah, USA
       <br/>
       <a href="http://www.cs.utah.edu/~regehr/">
        My web page
       </a>
      </div>
     </li>
     <li class="widget widget_search" id="search">
      <h3 class="widgettitle">
       <label for="s">
        Search
       </label>
      </h3>
      <form action="http://blog.regehr.org" id="searchform" method="get">
       <div>
        <input accesskey="S" class="text-input" id="s" name="s" size="10" tabindex="1" type="text" value=""/>
        <input class="submit-button" id="searchsubmit" name="searchsubmit" tabindex="2" type="submit" value="Search"/>
       </div>
      </form>
     </li>
     <li class="widget widget_categories" id="categories-3">
      <h3 class="widgettitle">
       Categories
      </h3>
      <ul>
       <li class="cat-item cat-item-7">
        <a href="http://blog.regehr.org/archives/category/academia">
         Academia
        </a>
        (111)
       </li>
       <li class="cat-item cat-item-11">
        <a href="http://blog.regehr.org/archives/category/books">
         Books
        </a>
        (19)
       </li>
       <li class="cat-item cat-item-15">
        <a href="http://blog.regehr.org/archives/category/compilers">
         Compilers
        </a>
        (92)
       </li>
       <li class="cat-item cat-item-6">
        <a href="http://blog.regehr.org/archives/category/cs">
         Computer Science
        </a>
        (289)
       </li>
       <li class="cat-item cat-item-12">
        <a href="http://blog.regehr.org/archives/category/education">
         Education
        </a>
        (52)
       </li>
       <li class="cat-item cat-item-5">
        <a href="http://blog.regehr.org/archives/category/embedded">
         Embedded
        </a>
        (28)
       </li>
       <li class="cat-item cat-item-8">
        <a href="http://blog.regehr.org/archives/category/food-and-drink">
         Food and drink
        </a>
        (4)
       </li>
       <li class="cat-item cat-item-10">
        <a href="http://blog.regehr.org/archives/category/futurist">
         Futurist
        </a>
        (20)
       </li>
       <li class="cat-item cat-item-3">
        <a href="http://blog.regehr.org/archives/category/outdoors">
         Outdoors
        </a>
        (55)
       </li>
       <li class="cat-item cat-item-9">
        <a href="http://blog.regehr.org/archives/category/parenthood">
         Parenthood
        </a>
        (4)
       </li>
       <li class="cat-item cat-item-14">
        <a href="http://blog.regehr.org/archives/category/random">
         Random
        </a>
        (37)
       </li>
       <li class="cat-item cat-item-16">
        <a href="http://blog.regehr.org/archives/category/software-correctness">
         Software Correctness
        </a>
        (179)
       </li>
       <li class="cat-item cat-item-4">
        <a href="http://blog.regehr.org/archives/category/utah">
         Utah
        </a>
        (55)
       </li>
      </ul>
     </li>
     <li class="widget widget_recent_entries" id="recent-posts-3">
      <h3 class="widgettitle">
       Recent Posts
      </h3>
      <ul>
       <li>
        <a href="http://blog.regehr.org/archives/1241">
         Defending Against Compiler-Based Backdoors
        </a>
       </li>
       <li>
        <a href="http://blog.regehr.org/archives/1246">
         Generating a Random Program vs. Generating All Programs
        </a>
       </li>
       <li>
        <a href="http://blog.regehr.org/archives/1238">
         What afl-fuzz Is Bad At
        </a>
       </li>
       <li>
        <a href="http://blog.regehr.org/archives/1234">
         UB Canaries
        </a>
       </li>
       <li>
        <a href="http://blog.regehr.org/archives/1225">
         Inexpensive CPU Monster
        </a>
       </li>
      </ul>
     </li>
     <li class="widget widget_links" id="linkcat-2">
      <h3 class="widgettitle">
       Blogroll
      </h3>
      <ul class="xoxo blogroll">
       <li>
        <a href="http://www.daniel-lemire.com/blog/">
         Daniel Lemire
        </a>
       </li>
       <li>
        <a href="http://noplacelikehomes.blogspot.com/">
         Derek Hoff
        </a>
       </li>
       <li>
        <a href="http://emeryblogger.wordpress.com/">
         Emery Berger
        </a>
       </li>
       <li>
        <a href="http://femalecomputerscientist.blogspot.com/">
         Female Computer Scientist
        </a>
       </li>
       <li>
        <a href="http://blog.frama-c.com/">
         Frama-C
        </a>
       </li>
       <li>
        <a href="http://blog.llvm.org/">
         LLVM Blog
        </a>
       </li>
       <li>
        <a href="http://matt.might.net/articles/">
         Matt Might
        </a>
       </li>
       <li>
        <a href="http://matt-welsh.blogspot.com/">
         Matt Welsh
        </a>
       </li>
       <li>
        <a href="http://embeddedgurus.com/stack-overflow/">
         Nigel Jones
        </a>
       </li>
       <li>
        <a href="http://betterembsw.blogspot.com/">
         Philip Koopman
        </a>
       </li>
       <li>
        <a href="http://geomblog.blogspot.com/">
         Suresh Venkatasubramanian
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </div>
   <div id="footer">
    <span id="copyright">
      2015
     <span class="vcard">
      <a class="url fn n" href="http://www.cs.utah.edu/~regehr/">
       <span class="given-name">
        John
       </span>
       <span class="family-name">
        Regehr
       </span>
      </a>
     </span>
    </span>
    <span class="meta-sep">
     |
    </span>
    <span id="generator-link">
     Thanks,
     <a href="http://wordpress.org/" rel="generator" title="WordPress">
      WordPress
     </a>
    </span>
    <span class="meta-sep">
     |
    </span>
    <span id="theme-link">
     <a href="http://www.plaintxt.org/themes/barthelme/" rel="follow designer" title="Barthelme theme for WordPress">
      Barthelme
     </a>
     theme by
     <span class="vcard">
      <a class="url fn n" href="http://scottwallick.com/" rel="follow designer" title="scottwallick.com">
       <span class="given-name">
        Scott
       </span>
       <span class="additional-name">
        Allan
       </span>
       <span class="family-name">
        Wallick
       </span>
      </a>
     </span>
    </span>
    <!-- Theme design credit, that's all -->
    <span class="meta-sep">
     |
    </span>
    <span id="web-standards">
     Standards Compliant
     <a href="http://validator.w3.org/check/referer" title="Valid XHTML">
      XHTML
     </a>
     &amp;
     <a href="http://jigsaw.w3.org/css-validator/validator?profile=css2&amp;warning=2&amp;uri=http://blog.regehr.org/wp-content/themes/barthelme/style.css" title="Valid CSS">
      CSS
     </a>
    </span>
    <span class="meta-sep">
     |
    </span>
    <span id="footer-rss">
     RSS
     <a href="http://blog.regehr.org/feed" rel="alternate" title="Embedded in Academia RSS 2.0 Feed" type="application/rss+xml">
      Posts
     </a>
     &amp;
     <a href="http://blog.regehr.org/comments/feed" rel="alternate" title="Embedded in Academia Comments RSS 2.0 Feed" type="application/rss+xml">
      Comments
     </a>
    </span>
   </div>
   <!-- #footer -->
   <!-- ngg_resource_manager_marker -->
   <script src="http://blog.regehr.org/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9b" type="text/javascript">
   </script>
   <script src="http://blog.regehr.org/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushPlain.js?ver=3.0.9b" type="text/javascript">
   </script>
   <script type="text/javascript">
    (function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://blog.regehr.org/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9b";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://blog.regehr.org/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9b";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['pad-line-numbers'] = false;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
   </script>
   <!--stats_footer_test-->
   <script src="http://stats.wordpress.com/e-201529.js" type="text/javascript">
   </script>
   <script type="text/javascript">
    st_go({blog:'11993579',v:'ext',post:'28'});
var load_cmc = function(){linktracker_init(11993579,28,2);};
if ( typeof addLoadEvent != 'undefined' ) addLoadEvent(load_cmc);
else load_cmc();
   </script>
  </div>
  <!-- #wrapper -->
 </body>
 <!-- end trasmission -->
</html>