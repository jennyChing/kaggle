<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html dir="ltr" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>
   PostgreSQL: Documentation: 8.3: Database Access from PL/Perl
  </title>
  <style media="screen" title="Normal Text" type="text/css">
   @import url("/dyncss/docs.css?9729558e");
  </style>
  <script src="/media/js/monospacefix.js?9729558e" type="text/javascript">
  </script>
  <script type="text/javascript">
   var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1345454-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  </script>
 </head>
 <body>
  <div id="docHeader">
   <div id="docHeaderLogo">
    <a href="/" title="PostgreSQL">
     <img alt="PostgreSQL" height="80" src="/media/img/docs/hdr_logo.png" width="206"/>
    </a>
   </div>
  </div>
  <div id="docContainerWrap">
   <div id="docContainer">
    <div id="docNavSearchContainer">
     <div id="docSearch">
      <form action="/search/" method="get">
       <div>
        <input name="u" type="hidden" value="/docs/8.3/"/>
        <label for="q">
         Search Documentation:
        </label>
        <input id="q" name="q" onfocus="if( this.value==this.defaultValue ) this.value='';" size="20" type="text" value="Search"/>
        <input id="submit" type="submit" value="Search"/>
       </div>
      </form>
     </div>
     <div id="docNav">
      <a href="/" title="Home">
       Home
      </a>
      
      <a href="/docs" title="Documentation">
       Documentation
      </a>
      
      <a href="/docs/manuals" title="Manuals">
       Manuals
      </a>
      
      <a href="/docs/8.3/static/index.html">
       PostgreSQL 8.3
      </a>
     </div>
     <div id="docVersions">
      This page in other versions:





Unsupported versions:
      <a href="/docs/7.3/static/plperl-database.html" rel="nofollow" title="This page in version 7.3">
       7.3
      </a>
      /
      <a href="/docs/7.4/static/plperl-database.html" rel="nofollow" title="This page in version 7.4">
       7.4
      </a>
      /
      <a href="/docs/8.0/static/plperl-database.html" rel="nofollow" title="This page in version 8.0">
       8.0
      </a>
      /
      <a href="/docs/8.1/static/plperl-database.html" rel="nofollow" title="This page in version 8.1">
       8.1
      </a>
      /
      <a href="/docs/8.2/static/plperl-database.html" rel="nofollow" title="This page in version 8.2">
       8.2
      </a>
      /
      <b>
       8.3
      </b>
      /
      <a href="/docs/8.4/static/plperl-database.html" rel="nofollow" title="This page in version 8.4">
       8.4
      </a>
     </div>
    </div>
    <div id="docContent">
     <div class="NAVHEADER">
      <table border="0" cellpadding="0" cellspacing="0" summary="Header navigation table" width="100%">
       <tr>
        <th align="center" colspan="5" valign="bottom">
         PostgreSQL
      8.3.23 Documentation
        </th>
       </tr>
       <tr>
        <td align="left" valign="top" width="10%">
         <a accesskey="P" href="plperl-funcs.html">
          Prev
         </a>
        </td>
        <td align="left" valign="top" width="10%">
         <a href="plperl.html">
          Fast Backward
         </a>
        </td>
        <td align="center" valign="bottom" width="60%">
         Chapter 40.
      PL/Perl - Perl Procedural Language
        </td>
        <td align="right" valign="top" width="10%">
         <a href="plperl.html">
          Fast Forward
         </a>
        </td>
        <td align="right" valign="top" width="10%">
         <a accesskey="N" href="plperl-data.html">
          Next
         </a>
        </td>
       </tr>
      </table>
      <hr class="c1" width="100%"/>
     </div>
     <div class="SECT1">
      <h1 class="SECT1">
       <a id="PLPERL-DATABASE" name="PLPERL-DATABASE">
        40.2. Database Access from PL/Perl
       </a>
      </h1>
      <p>
       Access to the database itself from your Perl function can be
  done via the function
       <code class="FUNCTION">
        spi_exec_query
       </code>
       described below, or via an
  experimental module
       <a href="http://www.cpan.org/modules/by-module/DBD/APILOS/" target="_top">
        <tt class="LITERAL">
         DBD::PgSPI
        </tt>
       </a>
       (also available at
       <a href="http://www.cpan.org/SITES.html" target="_top">
        <acronym class="ACRONYM">
         CPAN mirror sites
        </acronym>
       </a>
       ).
  This module makes available a
       <acronym class="ACRONYM">
        DBI
       </acronym>
       -compliant database-handle named
       <tt class="VARNAME">
        $pg_dbh
       </tt>
       that can be used to perform
  queries with normal
       <acronym class="ACRONYM">
        DBI
       </acronym>
       syntax.
       <a id="AEN45604" name="AEN45604">
       </a>
      </p>
      <p>
       PL/Perl provides additional Perl commands:
      </p>
      <div class="VARIABLELIST">
       <dl>
        <dt>
         <tt class="LITERAL">
          <code class="FUNCTION">
           spi_exec_query
          </code>
          (
          <tt class="REPLACEABLE c2">
           query
          </tt>
          [,
          <tt class="REPLACEABLE c2">
           max-rows
          </tt>
          ])
         </tt>
         <br/>
         <tt class="LITERAL">
          <code class="FUNCTION">
           spi_query
          </code>
          (
          <tt class="REPLACEABLE c2">
           command
          </tt>
          )
         </tt>
         <br/>
         <tt class="LITERAL">
          <code class="FUNCTION">
           spi_fetchrow
          </code>
          (
          <tt class="REPLACEABLE c2">
           cursor
          </tt>
          )
         </tt>
         <br/>
         <tt class="LITERAL">
          <code class="FUNCTION">
           spi_prepare
          </code>
          (
          <tt class="REPLACEABLE c2">
           command
          </tt>
          ,
          <tt class="REPLACEABLE c2">
           argument types
          </tt>
          )
         </tt>
         <br/>
         <tt class="LITERAL">
          <code class="FUNCTION">
           spi_exec_prepared
          </code>
          (
          <tt class="REPLACEABLE c2">
           plan
          </tt>
          )
         </tt>
         <br/>
         <tt class="LITERAL">
          <code class="FUNCTION">
           spi_query_prepared
          </code>
          (
          <tt class="REPLACEABLE c2">
           plan
          </tt>
          [,
          <tt class="REPLACEABLE c2">
           attributes
          </tt>
          ],
          <tt class="REPLACEABLE c2">
           arguments
          </tt>
          )
         </tt>
         <br/>
         <tt class="LITERAL">
          <code class="FUNCTION">
           spi_cursor_close
          </code>
          (
          <tt class="REPLACEABLE c2">
           cursor
          </tt>
          )
         </tt>
         <br/>
         <tt class="LITERAL">
          <code class="FUNCTION">
           spi_freeplan
          </code>
          (
          <tt class="REPLACEABLE c2">
           plan
          </tt>
          )
         </tt>
        </dt>
        <dd>
         <p>
          <tt class="LITERAL">
           spi_exec_query
          </tt>
          executes an SQL
        command and returns the entire row set as a reference to an
        array of hash references.
          <span class="emphasis EMPHASIS c3">
           You should only use this command
        when you know that the result set will be relatively
        small.
          </span>
          Here is an example of a query (
          <tt class="COMMAND">
           SELECT
          </tt>
          command) with the optional maximum
        number of rows:
         </p>
         <pre class="PROGRAMLISTING">
          $rv = spi_exec_query('SELECT * FROM my_table', 5);
         </pre>
         <p>
          This returns up to 5 rows from the table
          <tt class="LITERAL">
           my_table
          </tt>
          . If
          <tt class="LITERAL">
           my_table
          </tt>
          has a column
          <tt class="LITERAL">
           my_column
          </tt>
          , you can get that value from row
          <tt class="LITERAL">
           $i
          </tt>
          of the result like this:
         </p>
         <pre class="PROGRAMLISTING">
          $foo = $rv-&gt;{rows}[$i]-&gt;{my_column};
         </pre>
         <p>
          The total number of rows returned from a
          <tt class="COMMAND">
           SELECT
          </tt>
          query can be accessed like this:
         </p>
         <pre class="PROGRAMLISTING">
          $nrows = $rv-&gt;{processed}
         </pre>
         <p>
          Here is an example using a different command type:
         </p>
         <pre class="PROGRAMLISTING">
          $query = "INSERT INTO my_table VALUES (1, 'test')";
$rv = spi_exec_query($query);
         </pre>
         <p>
          You can then access the command status (e.g.,
          <tt class="LITERAL">
           SPI_OK_INSERT
          </tt>
          ) like this:
         </p>
         <pre class="PROGRAMLISTING">
          $res = $rv-&gt;{status};
         </pre>
         <p>
          To get the number of rows affected, do:
         </p>
         <pre class="PROGRAMLISTING">
          $nrows = $rv-&gt;{processed};
         </pre>
         <p>
          Here is a complete example:
         </p>
         <pre class="PROGRAMLISTING">
          CREATE TABLE test (
    i int,
    v varchar
);

INSERT INTO test (i, v) VALUES (1, 'first line');
INSERT INTO test (i, v) VALUES (2, 'second line');
INSERT INTO test (i, v) VALUES (3, 'third line');
INSERT INTO test (i, v) VALUES (4, 'immortal');

CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        return_next($row);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();
         </pre>
         <p>
          <tt class="LITERAL">
           spi_query
          </tt>
          and
          <tt class="LITERAL">
           spi_fetchrow
          </tt>
          work together as a pair for row
        sets which might be large, or for cases where you wish to
        return rows as they arrive.
          <tt class="LITERAL">
           spi_fetchrow
          </tt>
          works
          <span class="emphasis EMPHASIS c3">
           only
          </span>
          with
          <tt class="LITERAL">
           spi_query
          </tt>
          . The following example illustrates
        how you use them together:
         </p>
         <pre class="PROGRAMLISTING">
          CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);

CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$
    use Digest::MD5 qw(md5_hex);
    my $file = '/usr/share/dict/words';
    my $t = localtime;
    elog(NOTICE, "opening file $file at $t" );
    open my $fh, '&lt;', $file # ooh, it's a file access!
        or elog(ERROR, "cannot open $file for reading: $!");
    my @words = &lt;$fh&gt;;
    close $fh;
    $t = localtime;
    elog(NOTICE, "closed file $file at $t");
    chomp(@words);
    my $row;
    my $sth = spi_query("SELECT * FROM generate_series(1,$_[0]) AS b(a)");
    while (defined ($row = spi_fetchrow($sth))) {
        return_next({
            the_num =&gt; $row-&gt;{a},
            the_text =&gt; md5_hex($words[rand @words])
        });
    }
    return;
$$ LANGUAGE plperlu;

SELECT * from lotsa_md5(500);
         </pre>
         <p>
          <tt class="LITERAL">
           spi_prepare
          </tt>
          ,
          <tt class="LITERAL">
           spi_query_prepared
          </tt>
          ,
          <tt class="LITERAL">
           spi_exec_prepared
          </tt>
          , and
          <tt class="LITERAL">
           spi_freeplan
          </tt>
          implement the same
        functionality but for prepared queries. Once a query plan
        is prepared by a call to
          <tt class="LITERAL">
           spi_prepare
          </tt>
          , the plan can be used instead of
        the string query, either in
          <tt class="LITERAL">
           spi_exec_prepared
          </tt>
          , where the result is the
        same as returned by
          <tt class="LITERAL">
           spi_exec_query
          </tt>
          , or in
          <tt class="LITERAL">
           spi_query_prepared
          </tt>
          which returns a cursor
        exactly as
          <tt class="LITERAL">
           spi_query
          </tt>
          does, which
        can be later passed to
          <tt class="LITERAL">
           spi_fetchrow
          </tt>
          .
         </p>
         <p>
          The advantage of prepared queries is that is it possible
        to use one prepared plan for more than one query execution.
        After the plan is not needed anymore, it can be freed with
          <tt class="LITERAL">
           spi_freeplan
          </tt>
          :
         </p>
         <pre class="PROGRAMLISTING">
          CREATE OR REPLACE FUNCTION init() RETURNS INTEGER AS $$
        $_SHARED{my_plan} = spi_prepare( 'SELECT (now() + $1)::date AS now', 'INTERVAL');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$
        return spi_exec_prepared( 
                $_SHARED{my_plan},
                $_[0],
        )-&gt;{rows}-&gt;[0]-&gt;{now};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION done() RETURNS INTEGER AS $$
        spi_freeplan( $_SHARED{my_plan});
        undef $_SHARED{my_plan};
$$ LANGUAGE plperl;

SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();

  add_time  |  add_time  |  add_time  
------------+------------+------------
 2005-12-10 | 2005-12-11 | 2005-12-12
         </pre>
         <p>
          Note that the parameter subscript in
          <tt class="LITERAL">
           spi_prepare
          </tt>
          is defined via $1, $2, $3, etc,
        so avoid declaring query strings in double quotes that
        might easily lead to hard-to-catch bugs.
         </p>
         <p>
          Normally,
          <code class="FUNCTION">
           spi_fetchrow
          </code>
          should be repeated until it returns
          <tt class="LITERAL">
           undef
          </tt>
          , indicating that there are no more
        rows to read. The cursor is automatically freed when
          <code class="FUNCTION">
           spi_fetchrow
          </code>
          returns
          <tt class="LITERAL">
           undef
          </tt>
          . If you do not wish to read
        all the rows, instead call
          <code class="FUNCTION">
           spi_cursor_close
          </code>
          to free the cursor.
        Failure to do so will result in memory leaks.
         </p>
        </dd>
        <dt>
         <tt class="LITERAL">
          <code class="FUNCTION">
           elog
          </code>
          (
          <tt class="REPLACEABLE c2">
           level
          </tt>
          ,
          <tt class="REPLACEABLE c2">
           msg
          </tt>
          )
         </tt>
        </dt>
        <dd>
         <p>
          Emit a log or error message. Possible levels are
          <tt class="LITERAL">
           DEBUG
          </tt>
          ,
          <tt class="LITERAL">
           LOG
          </tt>
          ,
          <tt class="LITERAL">
           INFO
          </tt>
          ,
          <tt class="LITERAL">
           NOTICE
          </tt>
          ,
          <tt class="LITERAL">
           WARNING
          </tt>
          , and
          <tt class="LITERAL">
           ERROR
          </tt>
          .
          <tt class="LITERAL">
           ERROR
          </tt>
          raises an error condition;
        if this is not trapped by the surrounding Perl code, the
        error propagates out to the calling query, causing the
        current transaction or subtransaction to be aborted. This
        is effectively the same as the Perl
          <tt class="LITERAL">
           die
          </tt>
          command. The other levels only generate
        messages of different priority levels. Whether messages of
        a particular priority are reported to the client, written
        to the server log, or both is controlled by the
          <a href="runtime-config-logging.html#GUC-LOG-MIN-MESSAGES">
           log_min_messages
          </a>
          and
          <a href="runtime-config-logging.html#GUC-CLIENT-MIN-MESSAGES">
           client_min_messages
          </a>
          configuration variables. See
          <a href="runtime-config.html">
           Chapter 18
          </a>
          for more
        information.
         </p>
        </dd>
       </dl>
      </div>
     </div>
     <div class="NAVFOOTER">
      <hr class="c1" width="100%"/>
      <table border="0" cellpadding="0" cellspacing="0" summary="Footer navigation table" width="100%">
       <tr>
        <td align="left" valign="top" width="33%">
         <a accesskey="P" href="plperl-funcs.html">
          Prev
         </a>
        </td>
        <td align="center" valign="top" width="34%">
         <a accesskey="H" href="index.html">
          Home
         </a>
        </td>
        <td align="right" valign="top" width="33%">
         <a accesskey="N" href="plperl-data.html">
          Next
         </a>
        </td>
       </tr>
       <tr>
        <td align="left" valign="top" width="33%">
         PL/Perl Functions
      and Arguments
        </td>
        <td align="center" valign="top" width="34%">
         <a accesskey="U" href="plperl.html">
          Up
         </a>
        </td>
        <td align="right" valign="top" width="33%">
         Data Values in
      PL/Perl
        </td>
       </tr>
      </table>
     </div>
    </div>
    <div id="docComments">
    </div>
    <div id="docFooter">
     <a href="/about/privacypolicy">
      Privacy Policy
     </a>
     |
     <a href="/about/">
      About PostgreSQL
     </a>
     <br/>
     Copyright  1996-2015 The PostgreSQL Global Development Group
    </div>
   </div>
  </div>
 </body>
</html>